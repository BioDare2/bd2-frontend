import * as i0 from '@angular/core';
import { Injectable, Component, ChangeDetectionStrategy, Input, ViewChild, NgModule } from '@angular/core';
import { Subject, timer } from 'rxjs';
import { scaleLinear, scaleBand, scaleQuantize } from 'd3-scale';
import { rgb } from 'd3-color';
import { range } from 'd3-array';
import { format } from 'd3-format';
import { interpolateSpectral } from 'd3-scale-chromatic';
import * as i1 from '@angular/common';
import { CommonModule } from '@angular/common';
import { map, tap, debounceTime } from 'rxjs/operators';

class LookAndFeelSizing {
    constructor() {
        this.vMargin = 25;
        this.hMargin = 20;
        this.smallRowWidth = 6;
        this.midRowWidth = 12;
        this.bigRowWidth = 25;
        this.rowGap = 0.05;
    }
}
class GraphicContext {
}
class Tick {
    // tslint:disable-next-line:no-unnecessary-initializer
    constructor(x = 0, y = 0, label = undefined, top = false, left = false) {
        this.x = x;
        this.y = y;
        this.label = label;
        this.top = top;
        this.left = left;
    }
}
class BoxDef {
    constructor(x, y, left, right) {
        this.x = x;
        this.y = y;
        this.left = left;
        this.right = right;
        this.width = right - left;
    }
}
class BoxSerie {
}

class TooltipService {
    constructor() {
        this.request$ = new Subject();
    }
    showTooltip(label, point, location) {
        this.request$.next([true, label, point, location]);
    }
    hideTooltip(point, location) {
        this.request$.next([false, undefined, point, location]);
    }
    ngOnDestroy() {
        this.request$.complete();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: TooltipService, deps: [], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: TooltipService }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: TooltipService, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return []; } });

class HeatmapDataUtil {
    seriesToBoxes(series, asymmetric = false) {
        return series.map(s => this.serieToBoxes(s, asymmetric));
    }
    serieToBoxes(org, asymmetric = false) {
        const cpy = Object.assign(new BoxSerie(), org);
        cpy.data = asymmetric ? this.pointsToAsymBoxes(org.data) : this.pointsToSymBoxes(org.data);
        return cpy;
    }
    pointsToAsymBoxes(points, defMargin = 0.5) {
        if (!points || points.length === 0) {
            return [];
        }
        if (points.length === 1) {
            const point = points[0];
            return [new BoxDef(point.x, point.y, point.x - defMargin, point.x + defMargin)];
        }
        const boxes = [];
        const first = points[0];
        boxes.push(new BoxDef(first.x, first.y, (3 * first.x - points[1].x) / 2, (first.x + points[1].x) / 2));
        for (let i = 1; i < (points.length - 1); i++) {
            boxes.push(this.asymBoxFromPoints(points[i], points[i - 1], points[i + 1]));
        }
        const last = points[points.length - 1];
        boxes.push(new BoxDef(last.x, last.y, (points[points.length - 2].x + last.x) / 2, (3 * last.x - points[points.length - 2].x) / 2));
        return boxes;
    }
    asymBoxFromPoints(point, prev, next) {
        return new BoxDef(point.x, point.y, (prev.x + point.x) / 2, (point.x + next.x) / 2);
    }
    pointsToSymBoxes(points, defMargin = 0.5) {
        if (!points || points.length === 0) {
            return [];
        }
        if (points.length === 1) {
            const point = points[0];
            return [new BoxDef(point.x, point.y, point.x - defMargin, point.x + defMargin)];
        }
        const boxes = [];
        const first = points[0];
        boxes.push(new BoxDef(first.x, first.y, (3 * first.x - points[1].x) / 2, (first.x + points[1].x) / 2));
        for (let i = 1; i < (points.length - 1); i++) {
            boxes.push(this.symBoxFromPoints(points[i], points[i - 1], points[i + 1]));
        }
        const last = points[points.length - 1];
        boxes.push(new BoxDef(last.x, last.y, (points[points.length - 2].x + last.x) / 2, (3 * last.x - points[points.length - 2].x) / 2));
        return boxes;
    }
    symBoxFromPoints(point, prev, next) {
        const defL = point.x - prev.x;
        const defR = next.x - point.x;
        const def = Math.min(defL, defR) / 2;
        return new BoxDef(point.x, point.y, point.x - def, point.x + def);
    }
}

function colors(minColor = '#d62728', zeroColor = 'white', maxColor = '#1f77b4', step = 0.1) {
    const scale = scaleLinear()
        .domain([-1, 0, 1])
        .range([rgb(minColor), rgb(zeroColor), rgb(maxColor)]);
    const points = range(-1, 1 + step, step);
    const ranges = points.map(point => rgb(scale(point)).hex());
    return ranges;
}

class HeatmapGraphUtil {
    prepareGraphicContext(data, lookAndFeel, middleZero = false) {
        const context = new GraphicContext();
        this.calculateDimensions(context, data, lookAndFeel);
        this.addPaneAttributes(context, lookAndFeel);
        this.addScales(context, data, lookAndFeel, middleZero);
        this.addFormatters(context, data);
        context.labelsColors = this.labelsColors(data);
        return context;
    }
    calculateDimensions(context, data, lookAndFeel) {
        context.pWidth = 500;
        context.workspaceWidth = context.pWidth - 3 * lookAndFeel.hMargin;
        context.workspaceHeight = this.calculateWorkspaceHeight(data, lookAndFeel);
        context.pHeight = context.workspaceHeight + 2 * lookAndFeel.vMargin;
    }
    calculateWorkspaceHeight(data, lookAndFeel) {
        if (data.length <= 25) {
            return data.length * lookAndFeel.bigRowWidth;
        }
        if (data.length <= 100) {
            return data.length * lookAndFeel.midRowWidth;
        }
        return data.length * lookAndFeel.smallRowWidth;
    }
    addPaneAttributes(context, lookAndFeel) {
        context.viewBox = `0 0 500 ${context.pHeight}`;
        context.mainPaneTransform = `translate(${2 * lookAndFeel.hMargin}, ${lookAndFeel.vMargin})`;
    }
    addScales(context, data, lookAndFeel, middleZero) {
        let timeDomain = this.timeDomain(data);
        context.xDomain = timeDomain;
        const margin = this.timeMargin(data, timeDomain);
        timeDomain = [timeDomain[0] - margin, timeDomain[1] + margin];
        context.xScale = scaleLinear()
            .clamp(true)
            .domain(timeDomain)
            .range([0, context.workspaceWidth]);
        const yDomain = data.map(s => s.key);
        context.yDomain = yDomain;
        context.yScale = scaleBand()
            .paddingInner(lookAndFeel.rowGap)
            .paddingOuter(0)
            .domain(yDomain)
            .range([0, context.workspaceHeight]);
        context.colorScale = this.heatmapScale(data, middleZero);
    }
    addFormatters(context, data) {
        const timeDomain = this.timeDomain(data);
        context.domainFormatter = this.formatForDomain(timeDomain);
        const valuesRange = this.valuesRange(data);
        context.valuesFormatter = this.formatForDomain(valuesRange);
    }
    timeMargin(data, timeDomain) {
        const min = timeDomain[0];
        let margin = 0.5;
        data.filter(serie => serie.data && serie.data.length > 0 && serie.data[0].x === min)
            .forEach(serie => {
            const p = serie.data[0];
            if (p instanceof BoxDef) {
                margin = Math.max(margin, p.x - p.left);
            }
        });
        return margin;
    }
    timeDomain(data) {
        let min = Number.POSITIVE_INFINITY;
        let max = Number.NEGATIVE_INFINITY;
        data.forEach(serie => {
            if (serie.data && serie.data.length > 0) {
                min = Math.min(min, serie.data[0].x);
                max = Math.max(max, serie.data[serie.data.length - 1].x);
            }
        });
        min = isFinite(min) ? min : 0;
        max = isFinite(max) ? max : 1;
        return [min, max];
    }
    heatmapScale(data, middleZero) {
        let domain = this.valuesRange(data);
        if (middleZero) {
            const max = Math.max(Math.abs(domain[0]), Math.abs(domain[1]));
            domain = [-max, max];
        }
        const range = colors();
        return scaleQuantize().domain(domain).range(range);
    }
    valuesRange(traces) {
        if (traces.length === 0) {
            return [NaN, NaN];
        }
        let min = traces[0].min;
        let max = traces[0].max;
        traces.forEach(tr => {
            min = Math.min(min, tr.min);
            max = Math.max(max, tr.max);
        });
        return [min, max];
    }
    formatForDomain([min, max]) {
        const range = max - min;
        if (range < 1) {
            return format('.2~e');
        }
        if (range < 100) {
            return format('.2~f');
        }
        if (range < 100000) {
            return format('d');
        }
        return format('.2~e');
    }
    labelsColors(traces) {
        const size = traces.length;
        // tslint:disable-next-line:only-arrow-functions
        return function (i) {
            return interpolateSpectral(i / size);
        };
    }
}

class LabelBoxComponent {
    constructor(changeDetector) {
        this.changeDetector = changeDetector;
        this.alwaysOn = true;
        this.color = 'rgb(67, 125, 179)';
        this.textBWidth = 0;
        this.textBY = 0;
        this.toggled = false;
        this.ready = false;
    }
    ngOnInit() {
    }
    ngOnChanges(changes) {
        this.margin = this.marginSize();
        this.triggerY = this.yStart + this.margin;
        this.triggerHeight = this.margin > 1 ? this.maxHeight - 2 * this.margin : this.maxHeight - 1;
        this.yMiddle = this.yStart + this.maxHeight / 2;
    }
    marginSize() {
        if (this.maxHeight >= 20) {
            return 4;
        }
        if (this.maxHeight >= 12) {
            return 2;
        }
        return 1;
    }
    fontSize() {
        if (this.maxHeight > 12) {
            return 10;
        }
        if (this.maxHeight >= 6) {
            return this.maxHeight - 3;
        }
        return 0;
    }
    toggleLabel(val) {
        if (val === undefined) {
            val = !this.toggled;
        }
        this.ready = false;
        this.toggled = val;
        if (this.toggled) {
            this.updateTextBBox().subscribe(rect => {
                if (this.toggled) {
                    this.ready = true;
                }
                this.changeDetector.markForCheck();
            });
        }
    }
    updateTextBBox() {
        return timer(0).pipe(map(r => this.textBBox()), tap(rect => this.setTextBBox(rect)));
    }
    setTextBBox(rect) {
        this.textBY = rect.y - 4;
        this.textBHeight = rect.height + 8;
        this.textBWidth = rect.x + rect.width + 4;
    }
    textBBox() {
        if (!this.textNode) {
            return { x: 0, y: 0, height: 0, width: 0 };
        }
        return this.textNode.nativeElement.getBBox();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: LabelBoxComponent, deps: [{ token: i0.ChangeDetectorRef }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: LabelBoxComponent, selector: "[bd2hm-label-box]", inputs: { serie: "serie", yStart: "yStart", maxHeight: "maxHeight", alwaysOn: "alwaysOn", color: "color" }, viewQueries: [{ propertyName: "textNode", first: true, predicate: ["text"], descendants: true }], usesOnChanges: true, ngImport: i0, template: `
    <svg:g *ngIf="serie" class="bd2hm-label">
      <svg:text *ngIf="alwaysOn" x="5" [attr.y]="yMiddle" class="bd2hm-onLabel"
                [attr.font-size]="fontSize()"
      >{{serie.label}}</svg:text>

      <g (mouseout)="toggleLabel(false)" (mouseover)="toggleLabel(true)">
        <svg:rect x="-7" width="7" [attr.y]="triggerY" [attr.height]="triggerHeight" [attr.fill]="color"
        ></svg:rect>

        <!--<svg:circle [attr.cx]="-cirR()-2" [attr.cy]="yMiddle" [attr.r]="cirR()" [attr.fill]="'rgb(67, 125, 179)'"
                    [attr.filter]="band < 7 ? undefined : 'url(#bd2hm-shadow)'"
        ></svg:circle>-->

        <svg:g class="bd2hm-hover" [attr.opacity]="ready ? 1 : 0" [attr.display]="toggled ? undefined : 'none'">
          <svg:rect x="0" [attr.width]="textBWidth" [attr.y]="textBY" [attr.height]="textBHeight"
          ></svg:rect>
          <svg:text #text x="5" [attr.y]="yMiddle"
          >{{serie.label}}</svg:text>
        </svg:g>
      </g>
    </svg:g>
  `, isInline: true, dependencies: [{ kind: "directive", type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: LabelBoxComponent, decorators: [{
            type: Component,
            args: [{ selector: '[bd2hm-label-box]', template: `
    <svg:g *ngIf="serie" class="bd2hm-label">
      <svg:text *ngIf="alwaysOn" x="5" [attr.y]="yMiddle" class="bd2hm-onLabel"
                [attr.font-size]="fontSize()"
      >{{serie.label}}</svg:text>

      <g (mouseout)="toggleLabel(false)" (mouseover)="toggleLabel(true)">
        <svg:rect x="-7" width="7" [attr.y]="triggerY" [attr.height]="triggerHeight" [attr.fill]="color"
        ></svg:rect>

        <!--<svg:circle [attr.cx]="-cirR()-2" [attr.cy]="yMiddle" [attr.r]="cirR()" [attr.fill]="'rgb(67, 125, 179)'"
                    [attr.filter]="band < 7 ? undefined : 'url(#bd2hm-shadow)'"
        ></svg:circle>-->

        <svg:g class="bd2hm-hover" [attr.opacity]="ready ? 1 : 0" [attr.display]="toggled ? undefined : 'none'">
          <svg:rect x="0" [attr.width]="textBWidth" [attr.y]="textBY" [attr.height]="textBHeight"
          ></svg:rect>
          <svg:text #text x="5" [attr.y]="yMiddle"
          >{{serie.label}}</svg:text>
        </svg:g>
      </g>
    </svg:g>
  `, changeDetection: ChangeDetectionStrategy.OnPush }]
        }], ctorParameters: function () { return [{ type: i0.ChangeDetectorRef }]; }, propDecorators: { serie: [{
                type: Input
            }], yStart: [{
                type: Input
            }], maxHeight: [{
                type: Input
            }], alwaysOn: [{
                type: Input
            }], color: [{
                type: Input
            }], textNode: [{
                type: ViewChild,
                args: ['text']
            }] } });

class LabelsComponent {
    constructor() {
        this.alwaysOn = true;
    }
    trackByIndex(index, item) {
        return index;
    }
    ngOnInit() {
    }
    yStart(serie) {
        // return this.graphic.yScale(serie.key) + this.graphic.yScale.bandwidth() / 4;
        return this.graphic.yScale(serie.key);
    }
    maxHeight() {
        return this.graphic.yScale.bandwidth();
    }
    color(ix) {
        return this.graphic.labelsColors(ix);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: LabelsComponent, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: LabelsComponent, selector: "[bd2hm-labels]", inputs: { graphic: "graphic", data: "data", alwaysOn: "alwaysOn" }, ngImport: i0, template: `
    <svg:g *ngIf="graphic && data" class="bd2hm-labels">
      <svg:g bd2hm-label-box *ngFor="let serie of data; let ix = index; trackBy: trackByIndex"
             [serie]="serie"
             [yStart]="yStart(serie)" [maxHeight]="maxHeight()" [alwaysOn]="alwaysOn"
      ></svg:g>
    </svg:g>
  `, isInline: true, dependencies: [{ kind: "directive", type: i1.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "component", type: LabelBoxComponent, selector: "[bd2hm-label-box]", inputs: ["serie", "yStart", "maxHeight", "alwaysOn", "color"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: LabelsComponent, decorators: [{
            type: Component,
            args: [{ selector: '[bd2hm-labels]', template: `
    <svg:g *ngIf="graphic && data" class="bd2hm-labels">
      <svg:g bd2hm-label-box *ngFor="let serie of data; let ix = index; trackBy: trackByIndex"
             [serie]="serie"
             [yStart]="yStart(serie)" [maxHeight]="maxHeight()" [alwaysOn]="alwaysOn"
      ></svg:g>
    </svg:g>
  `, changeDetection: ChangeDetectionStrategy.OnPush }]
        }], ctorParameters: function () { return []; }, propDecorators: { graphic: [{
                type: Input
            }], data: [{
                type: Input
            }], alwaysOn: [{
                type: Input
            }] } });

// [attr.display]="showBack ? undefined : 'none'"
// [style.visibility]="showBack ? undefined :'hidden'"
class TooltipComponent {
    constructor(tooltip, changeDetector) {
        this.tooltip = tooltip;
        this.changeDetector = changeDetector;
        this.boxMargin = 4;
        this.show = false;
        this.ready = false;
    }
    ngOnInit() {
        this.subscription = this.tooltip.request$.pipe(debounceTime(100)).subscribe(request => this.handleRequest(request));
    }
    ngOnDestroy() {
        if (this.subscription) {
            this.subscription.unsubscribe();
        }
    }
    handleRequest([show, label, point, location]) {
        if (show) {
            this.showTooltip(label, point, location);
        }
        else {
            this.hideTooltip(point, location);
        }
    }
    showTooltip(label, point, location) {
        this.ready = false;
        this.label = this.formatLabel(label);
        this.values = this.formatValues(point);
        this.show = true;
        // change detection not mark as it can be called outside ngzone
        this.changeDetector.detectChanges();
        this.updateTextBBox().subscribe(rect => {
            if (this.show) {
                this.position = this.translateToDataLocation(location, this.textBWidth, this.graphic.workspaceWidth);
                this.ready = true;
            }
            // change detection not mark as it can be called outside ngzone
            // it has to be called again as textobox is determined after the timer so does the new position
            // this.changeDetector.markForCheck();
            this.changeDetector.detectChanges();
        });
    }
    translateToDataLocation(location, textBoxWidth, workspaceWidth) {
        let x = location.x + location.width + 2 * this.boxMargin;
        if ((x + textBoxWidth) >= workspaceWidth) {
            x = location.x - textBoxWidth;
        }
        const y = location.y;
        return `translate(${x}, ${y})`;
    }
    hideTooltip(point, location) {
        this.show = false;
        // this.changeDetector.markForCheck();
        this.changeDetector.detectChanges();
    }
    formatValues(point) {
        return `${this.graphic.domainFormatter(point.x)} : ${this.graphic.valuesFormatter(point.y)}`;
    }
    updateTextBBox() {
        return timer(0).pipe(map(r => this.textBBox()), tap(rect => this.setTextBBox(rect)));
    }
    setTextBBox(rect) {
        this.textBX = rect.x - this.boxMargin;
        this.textBY = rect.y - this.boxMargin;
        this.textBHeight = rect.height + 2 * this.boxMargin;
        this.textBWidth = rect.width + 2 * this.boxMargin;
    }
    textBBox() {
        if (!this.textNode) {
            return { x: 0, y: 0, height: 0, width: 0 };
        }
        return this.textNode.nativeElement.getBBox();
    }
    formatLabel(label) {
        if (!label) {
            return '';
        }
        if (label.length < 40) {
            return label;
        }
        return label.substring(0, 38) + '...';
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: TooltipComponent, deps: [{ token: TooltipService }, { token: i0.ChangeDetectorRef }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: TooltipComponent, selector: "[bd2hm-tooltip]", inputs: { graphic: "graphic", boxMargin: "boxMargin" }, viewQueries: [{ propertyName: "textNode", first: true, predicate: ["text"], descendants: true }], ngImport: i0, template: `
    <svg:g *ngIf="graphic" class="bd2hm-tooltipBox" [attr.display]="show ? undefined : 'none'" [attr.transform]="position">

      <svg:g [attr.opacity]="ready ? 1 : 0">
        <svg:rect [attr.x]="textBX" [attr.width]="textBWidth" [attr.y]="textBY" [attr.height]="textBHeight"
        ></svg:rect>

        <svg:text #text>
          <tspan x="0">{{label}}</tspan>
          <tspan x="0" dy="1.2em">{{values}}</tspan>
        </svg:text>
      </svg:g>

    </svg:g>
  `, isInline: true, dependencies: [{ kind: "directive", type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: TooltipComponent, decorators: [{
            type: Component,
            args: [{ selector: '[bd2hm-tooltip]', template: `
    <svg:g *ngIf="graphic" class="bd2hm-tooltipBox" [attr.display]="show ? undefined : 'none'" [attr.transform]="position">

      <svg:g [attr.opacity]="ready ? 1 : 0">
        <svg:rect [attr.x]="textBX" [attr.width]="textBWidth" [attr.y]="textBY" [attr.height]="textBHeight"
        ></svg:rect>

        <svg:text #text>
          <tspan x="0">{{label}}</tspan>
          <tspan x="0" dy="1.2em">{{values}}</tspan>
        </svg:text>
      </svg:g>

    </svg:g>
  `, changeDetection: ChangeDetectionStrategy.OnPush }]
        }], ctorParameters: function () { return [{ type: TooltipService }, { type: i0.ChangeDetectorRef }]; }, propDecorators: { graphic: [{
                type: Input
            }], boxMargin: [{
                type: Input
            }], textNode: [{
                type: ViewChild,
                args: ['text']
            }] } });

class PaneBackComponent {
    constructor() {
        this.margin = 2;
    }
    ngOnInit() {
    }
    ngOnChanges(changes) {
        this.width = this.graphic.workspaceWidth - 2 * this.margin;
        this.height = this.graphic.workspaceHeight - 2 * this.margin;
        if (this.width < 0) {
            this.width = 0;
        }
        if (this.height < 0) {
            this.height = 0;
        }
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: PaneBackComponent, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: PaneBackComponent, selector: "[bd2hm-pane-back]", inputs: { graphic: "graphic", margin: "margin" }, usesOnChanges: true, ngImport: i0, template: `
    <svg:rect class="bd2hm-dataBackground" [attr.x]="margin" [attr.y]="margin"
              [attr.width]="width" [attr.height]="height"
    >
    </svg:rect>
  `, isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: PaneBackComponent, decorators: [{
            type: Component,
            args: [{ selector: '[bd2hm-pane-back]', template: `
    <svg:rect class="bd2hm-dataBackground" [attr.x]="margin" [attr.y]="margin"
              [attr.width]="width" [attr.height]="height"
    >
    </svg:rect>
  `, changeDetection: ChangeDetectionStrategy.OnPush }]
        }], ctorParameters: function () { return []; }, propDecorators: { graphic: [{
                type: Input
            }], margin: [{
                type: Input
            }] } });

class DataPointBoxComponent {
    constructor(tooltip, zone) {
        this.tooltip = tooltip;
        this.zone = zone;
    }
    ngOnChanges(changes) {
        if (this.xScale && this.point) {
            this.xPosition = this.xScale(this.point.left);
            const band = this.xScale(this.point.right) - this.xScale(this.point.left);
            this.xWidth = band >= 2 ? band - 1 : 1;
        }
    }
    ngAfterViewInit() {
        if (this.boxNode) {
            if ((this.prevBoxNode !== this.boxNode)) {
                this.removeMouseListeners(this.prevBoxNode);
                this.zone.runOutsideAngular(() => {
                    this.addMouseListeners(this.boxNode);
                });
                this.prevBoxNode = this.boxNode;
            }
        }
    }
    ngOnInit() {
    }
    ngOnDestroy() {
        this.removeMouseListeners(this.boxNode);
    }
    addMouseListeners(elm) {
        if (elm) {
            elm.nativeElement.addEventListener('mouseover', this.showTooltip.bind(this));
            elm.nativeElement.addEventListener('mouseout', this.hideTooltip.bind(this));
        }
    }
    removeMouseListeners(elm) {
        if (elm) {
            elm.nativeElement.removeEventListener('mouseover', this.showTooltip);
            elm.nativeElement.removeEventListener('mouseout', this.hideTooltip);
        }
    }
    hideTooltip($event) {
        const location = { x: this.xPosition, y: this.yPosition, width: this.xWidth };
        this.tooltip.hideTooltip(this.point, location);
    }
    showTooltip($event) {
        const location = { x: this.xPosition, y: this.yPosition, width: this.xWidth };
        this.tooltip.showTooltip(this.label, this.point, location);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: DataPointBoxComponent, deps: [{ token: TooltipService }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: DataPointBoxComponent, selector: "[bd2hm-data-point-box]", inputs: { point: "point", yPosition: "yPosition", yHeight: "yHeight", xScale: "xScale", colorScale: "colorScale", label: "label" }, viewQueries: [{ propertyName: "boxNode", first: true, predicate: ["box"], descendants: true }], usesOnChanges: true, ngImport: i0, template: `
    <svg:rect #box *ngIf="point && xScale" [attr.x]="xPosition" [attr.y]="yPosition"
              [attr.width]="xWidth"
              [attr.height]="yHeight" [attr.fill]="colorScale(point.y)" [attr.stroke]="colorScale(point.y)"
    >
    </svg:rect>
  `, isInline: true, dependencies: [{ kind: "directive", type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: DataPointBoxComponent, decorators: [{
            type: Component,
            args: [{ selector: '[bd2hm-data-point-box]', template: `
    <svg:rect #box *ngIf="point && xScale" [attr.x]="xPosition" [attr.y]="yPosition"
              [attr.width]="xWidth"
              [attr.height]="yHeight" [attr.fill]="colorScale(point.y)" [attr.stroke]="colorScale(point.y)"
    >
    </svg:rect>
  `, changeDetection: ChangeDetectionStrategy.OnPush }]
        }], ctorParameters: function () { return [{ type: TooltipService }, { type: i0.NgZone }]; }, propDecorators: { boxNode: [{
                type: ViewChild,
                args: ['box']
            }], point: [{
                type: Input
            }], yPosition: [{
                type: Input
            }], yHeight: [{
                type: Input
            }], xScale: [{
                type: Input
            }], colorScale: [{
                type: Input
            }], label: [{
                type: Input
            }] } });

class SerieRowComponent {
    constructor() {
    }
    trackByIndex(index, item) {
        return index;
    }
    ngOnInit() {
    }
    ngOnChanges(changes) {
        if (this.graphic && this.serie) {
            this.yPosition = this.graphic.yScale(this.serie.key);
            this.yHeight = this.graphic.yScale.bandwidth();
        }
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: SerieRowComponent, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: SerieRowComponent, selector: "[bd2hm-serie-row]", inputs: { graphic: "graphic", serie: "serie" }, usesOnChanges: true, ngImport: i0, template: `
    <svg:g *ngIf="graphic && serie" class="bd2hm-serie">
      <svg:g *ngFor="let point of serie.data; trackBy: trackByIndex" bd2hm-data-point-box
             [point]="point" [xScale]="graphic.xScale"
             [yPosition]="yPosition"
             [yHeight]="yHeight" [colorScale]="graphic.colorScale"
             [label]="serie.label"
      ></svg:g>
    </svg:g>
  `, isInline: true, dependencies: [{ kind: "directive", type: i1.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "component", type: DataPointBoxComponent, selector: "[bd2hm-data-point-box]", inputs: ["point", "yPosition", "yHeight", "xScale", "colorScale", "label"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: SerieRowComponent, decorators: [{
            type: Component,
            args: [{ selector: '[bd2hm-serie-row]', template: `
    <svg:g *ngIf="graphic && serie" class="bd2hm-serie">
      <svg:g *ngFor="let point of serie.data; trackBy: trackByIndex" bd2hm-data-point-box
             [point]="point" [xScale]="graphic.xScale"
             [yPosition]="yPosition"
             [yHeight]="yHeight" [colorScale]="graphic.colorScale"
             [label]="serie.label"
      ></svg:g>
    </svg:g>
  `, changeDetection: ChangeDetectionStrategy.OnPush }]
        }], ctorParameters: function () { return []; }, propDecorators: { graphic: [{
                type: Input
            }], serie: [{
                type: Input
            }] } });

class SeriesBoxComponent {
    constructor() {
    }
    trackByIndex(index, item) {
        return index;
    }
    ngOnInit() {
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: SeriesBoxComponent, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: SeriesBoxComponent, selector: "[bd2hm-series-box]", inputs: { series: "series", graphic: "graphic" }, ngImport: i0, template: `
    <svg:g *ngFor="let serie of series; trackBy: trackByIndex"
           bd2hm-serie-row [graphic]="graphic" [serie]="serie"></svg:g>
  `, isInline: true, dependencies: [{ kind: "directive", type: i1.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "component", type: SerieRowComponent, selector: "[bd2hm-serie-row]", inputs: ["graphic", "serie"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: SeriesBoxComponent, decorators: [{
            type: Component,
            args: [{ selector: '[bd2hm-series-box]', template: `
    <svg:g *ngFor="let serie of series; trackBy: trackByIndex"
           bd2hm-serie-row [graphic]="graphic" [serie]="serie"></svg:g>
  `, changeDetection: ChangeDetectionStrategy.OnPush }]
        }], ctorParameters: function () { return []; }, propDecorators: { series: [{
                type: Input
            }], graphic: [{
                type: Input
            }] } });

class VTickMarkComponent {
    constructor() {
        this.length = 5;
    }
    ngOnInit() {
        this.calculatePositions();
    }
    ngOnChanges(changes) {
        this.calculatePositions();
    }
    calculatePositions() {
        this.marky2 = this.tick?.top ? -this.length : this.length;
        this.texty2 = this.tick?.top ? -(this.length + 4) : (this.length + 4);
        this.textdy = this.tick?.top ? 0 : '0.6em';
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: VTickMarkComponent, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: VTickMarkComponent, selector: "[bd2hm-vtick-mark]", inputs: { tick: "tick", length: "length" }, usesOnChanges: true, ngImport: i0, template: `
    <svg:line *ngIf="tick"
              [attr.x1]="tick.x" [attr.x2]="tick.x"
              y1="0" [attr.y2]="marky2"
    ></svg:line>
    <svg:text *ngIf="tick" [attr.x]="tick.x" [attr.y]="texty2" [attr.dy]="textdy">{{tick.label}}</svg:text>
  `, isInline: true, dependencies: [{ kind: "directive", type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: VTickMarkComponent, decorators: [{
            type: Component,
            args: [{ selector: '[bd2hm-vtick-mark]', template: `
    <svg:line *ngIf="tick"
              [attr.x1]="tick.x" [attr.x2]="tick.x"
              y1="0" [attr.y2]="marky2"
    ></svg:line>
    <svg:text *ngIf="tick" [attr.x]="tick.x" [attr.y]="texty2" [attr.dy]="textdy">{{tick.label}}</svg:text>
  ` }]
        }], ctorParameters: function () { return []; }, propDecorators: { tick: [{
                type: Input
            }], length: [{
                type: Input
            }] } });

//
class NumXAxisComponent {
    constructor() {
        this.top = false;
        this.ticks = [];
    }
    trackByIndex(index, item) {
        return index;
    }
    ngOnInit() {
    }
    ngOnChanges(changes) {
        this.axisTransform = `translate(0,${this.yPosition})`;
        this.x2 = this.xScale?.range()[1];
        this.ticks = this.prepareTicks(this.xScale);
    }
    prepareTicks(xScale) {
        const positions = this.calculateTicksPosition(xScale);
        return positions.map(tick => new Tick(xScale(tick), 0, tick, this.top, false));
    }
    calculateTicksPosition(xScale) {
        if (!xScale) {
            return [];
        }
        const ticks = [];
        const domain = this.xDomain || xScale.domain();
        const first = Math.round(domain[0]);
        const last = Math.round(domain[1]);
        const step = this.domainStep(last - first);
        for (let i = first; i <= last; i += step) {
            ticks.push(i);
        }
        return ticks;
    }
    domainStep(range) {
        if (range <= 25) {
            return 4;
        }
        if (range <= 73) {
            return 6;
        }
        if (range <= 169) {
            return 12;
        }
        return 24;
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: NumXAxisComponent, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: NumXAxisComponent, selector: "[bd2hm-num-x-axis]", inputs: { xScale: "xScale", xDomain: "xDomain", yPosition: "yPosition", top: "top" }, usesOnChanges: true, ngImport: i0, template: `
    <svg:g class="bd2hm-x-axis" [attr.transform]="axisTransform" >
      <svg:line x1="0" y1="0" y2="0" [attr.x2]="x2"></svg:line>
      <svg:g *ngFor="let tick of ticks; trackBy: trackByIndex" bd2hm-vtick-mark class="bd2hm-tickMark" [tick]="tick"></svg:g>
    </svg:g>
  `, isInline: true, dependencies: [{ kind: "directive", type: i1.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "component", type: VTickMarkComponent, selector: "[bd2hm-vtick-mark]", inputs: ["tick", "length"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: NumXAxisComponent, decorators: [{
            type: Component,
            args: [{ selector: '[bd2hm-num-x-axis]', template: `
    <svg:g class="bd2hm-x-axis" [attr.transform]="axisTransform" >
      <svg:line x1="0" y1="0" y2="0" [attr.x2]="x2"></svg:line>
      <svg:g *ngFor="let tick of ticks; trackBy: trackByIndex" bd2hm-vtick-mark class="bd2hm-tickMark" [tick]="tick"></svg:g>
    </svg:g>
  `, changeDetection: ChangeDetectionStrategy.OnPush }]
        }], ctorParameters: function () { return []; }, propDecorators: { xScale: [{
                type: Input
            }], xDomain: [{
                type: Input
            }], yPosition: [{
                type: Input
            }], top: [{
                type: Input
            }] } });

class YAxisComponent {
    constructor() {
        this.left = false;
    }
    ngOnInit() {
    }
    ngOnChanges(changes) {
        this.axisTransform = `translate(${this.xPosition},0)`;
        this.y2 = this.yScale?.range()[1];
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: YAxisComponent, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: YAxisComponent, selector: "[bd2hm-y-axis]", inputs: { yScale: "yScale", xPosition: "xPosition", left: "left" }, usesOnChanges: true, ngImport: i0, template: `
    <svg:g class="bd2hm-y-axis" [attr.transform]="axisTransform">
      <svg:line x1="0" y1="0" x2="0" [attr.y2]="y2"></svg:line>
    </svg:g>
  `, isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: YAxisComponent, decorators: [{
            type: Component,
            args: [{ selector: '[bd2hm-y-axis]', template: `
    <svg:g class="bd2hm-y-axis" [attr.transform]="axisTransform">
      <svg:line x1="0" y1="0" x2="0" [attr.y2]="y2"></svg:line>
    </svg:g>
  `, changeDetection: ChangeDetectionStrategy.OnPush }]
        }], ctorParameters: function () { return []; }, propDecorators: { yScale: [{
                type: Input
            }], xPosition: [{
                type: Input
            }], left: [{
                type: Input
            }] } });

class AxisBoxComponent {
    constructor() {
    }
    ngOnInit() {
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: AxisBoxComponent, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: AxisBoxComponent, selector: "[bd2hm-axis-box]", inputs: { graphic: "graphic" }, ngImport: i0, template: `
    <svg:g *ngIf="graphic" class="bd2hm-axisWrapper">
      <g bd2hm-num-x-axis class="xTopAxis" [top]="true" [xScale]="graphic.xScale"
         [yPosition]="0" [xDomain]="graphic.xDomain"></g>
      <g bd2hm-num-x-axis class="xBottomAxis" [top]="false" [xScale]="graphic.xScale"
         [yPosition]="graphic.workspaceHeight" [xDomain]="graphic.xDomain"></g>

      <g bd2hm-y-axis class="yLeftAxis" [left]="true" [yScale]="graphic.yScale" [xPosition]="0"></g>
      <g bd2hm-y-axis class="yRightAxis" [left]="false" [yScale]="graphic.yScale" [xPosition]="graphic.workspaceWidth"></g>
    </svg:g>
  `, isInline: true, dependencies: [{ kind: "directive", type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "component", type: NumXAxisComponent, selector: "[bd2hm-num-x-axis]", inputs: ["xScale", "xDomain", "yPosition", "top"] }, { kind: "component", type: YAxisComponent, selector: "[bd2hm-y-axis]", inputs: ["yScale", "xPosition", "left"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: AxisBoxComponent, decorators: [{
            type: Component,
            args: [{ selector: '[bd2hm-axis-box]', template: `
    <svg:g *ngIf="graphic" class="bd2hm-axisWrapper">
      <g bd2hm-num-x-axis class="xTopAxis" [top]="true" [xScale]="graphic.xScale"
         [yPosition]="0" [xDomain]="graphic.xDomain"></g>
      <g bd2hm-num-x-axis class="xBottomAxis" [top]="false" [xScale]="graphic.xScale"
         [yPosition]="graphic.workspaceHeight" [xDomain]="graphic.xDomain"></g>

      <g bd2hm-y-axis class="yLeftAxis" [left]="true" [yScale]="graphic.yScale" [xPosition]="0"></g>
      <g bd2hm-y-axis class="yRightAxis" [left]="false" [yScale]="graphic.yScale" [xPosition]="graphic.workspaceWidth"></g>
    </svg:g>
  `, changeDetection: ChangeDetectionStrategy.OnPush }]
        }], ctorParameters: function () { return []; }, propDecorators: { graphic: [{
                type: Input
            }] } });

class Bd2NumHeatmapComponent {
    constructor(changeDetector, tooltip) {
        this.changeDetector = changeDetector;
        this.tooltip = tooltip;
        this.asymmetric = false;
        this.middleZero = false;
        this.hidden = false;
        this.labelsAlwaysOn = true;
        this.lookAndFeel = new LookAndFeelSizing();
        this.heatmapDataUtil = new HeatmapDataUtil();
        this.heatmapGraphUtil = new HeatmapGraphUtil();
    }
    ngOnInit() {
        // this.changeDetector.detach();
    }
    ngOnDestroy() {
        if (this.tooltip) {
            this.tooltip.ngOnDestroy();
        }
    }
    ngOnChanges(changes) {
        if (this.data && this.data.length > 0) {
            this.series = this.heatmapDataUtil.seriesToBoxes(this.data, this.asymmetric);
            this.graphic = this.heatmapGraphUtil.prepareGraphicContext(this.series, this.lookAndFeel, this.middleZero);
        }
        else {
            this.graphic = undefined;
            this.series = undefined;
        }
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: Bd2NumHeatmapComponent, deps: [{ token: i0.ChangeDetectorRef }, { token: TooltipService }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: Bd2NumHeatmapComponent, selector: "bd2-num-heatmap", inputs: { data: "data", asymmetric: "asymmetric", middleZero: "middleZero", hidden: "hidden", labelsAlwaysOn: "labelsAlwaysOn", lookAndFeel: "lookAndFeel" }, providers: [TooltipService], usesOnChanges: true, ngImport: i0, template: "<div class=\"bd2hm-heatmap\" [hidden]=\"hidden\">\r\n  <svg *ngIf=\"graphic\" width=\"100%\" [attr.viewBox]=\"graphic.viewBox\">\r\n    <defs>\r\n      <filter id=\"bd2hm-shadow\">\r\n        <feDropShadow dx=\"1\" dy=\"1\" stdDeviation=\"1\"/>\r\n      </filter>\r\n      <pattern id=\"bd2hm-pattern-diagonal\" width=\"10\" height=\"10\" patternTransform=\"rotate(45 0 0)\"\r\n               patternUnits=\"userSpaceOnUse\">\r\n        <line x1=\"0\" y1=\"0\" x2=\"0\" y2=\"10\" style=\"stroke:lightgrey; stroke-width:1\"/>\r\n      </pattern>\r\n    </defs>\r\n\r\n    <g class=\"bd2hm-mainPane\" [attr.transform]=\"graphic.mainPaneTransform\">\r\n\r\n      <g bd2hm-pane-back [graphic]=\"graphic\" class=\"bd2hm-paneBack\"></g>\r\n\r\n\r\n      <g bd2hm-axis-box [graphic]=\"graphic\"></g>\r\n\r\n\r\n\r\n      <g bd2hm-series-box [graphic]=\"graphic\" [series]=\"series\" class=\"bd2hm-seriesBox\"></g>\r\n\r\n\r\n      <g bd2hm-labels [graphic]=\"graphic\" [data]=\"series\" [alwaysOn]=\"labelsAlwaysOn\"></g>\r\n\r\n      <g bd2hm-tooltip [graphic]=\"graphic\"></g>\r\n    </g>\r\n  </svg>\r\n  <!--{{ series | json }}-->\r\n</div>\r\n", styles: ["::ng-deep .bd2hm-paneBack rect{fill:url(#bd2hm-pattern-diagonal)}::ng-deep .bd2hm-axisWrapper line{stroke:gray}::ng-deep .bd2hm-axisWrapper text{fill:gray;text-anchor:middle;font-size:9px}::ng-deep .bd2hm-labels text.bd2hm-onLabel{dominant-baseline:central;fill:#000;opacity:.6}::ng-deep .bd2hm-labels .bd2hm-hover text{dominant-baseline:central;fill:#fff;font-size:10px}::ng-deep .bd2hm-labels .bd2hm-hover rect{fill:#000;opacity:.8;filter:url(#bd2hm-shadow)}::ng-deep .bd2hm-tooltipBox text{font-size:10px;fill:#fff}::ng-deep .bd2hm-tooltipBox rect{fill:#000;opacity:.8;filter:url(#bd2hm-shadow)}\n"], dependencies: [{ kind: "directive", type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "component", type: LabelsComponent, selector: "[bd2hm-labels]", inputs: ["graphic", "data", "alwaysOn"] }, { kind: "component", type: TooltipComponent, selector: "[bd2hm-tooltip]", inputs: ["graphic", "boxMargin"] }, { kind: "component", type: PaneBackComponent, selector: "[bd2hm-pane-back]", inputs: ["graphic", "margin"] }, { kind: "component", type: SeriesBoxComponent, selector: "[bd2hm-series-box]", inputs: ["series", "graphic"] }, { kind: "component", type: AxisBoxComponent, selector: "[bd2hm-axis-box]", inputs: ["graphic"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: Bd2NumHeatmapComponent, decorators: [{
            type: Component,
            args: [{ selector: 'bd2-num-heatmap', providers: [TooltipService], changeDetection: ChangeDetectionStrategy.OnPush, template: "<div class=\"bd2hm-heatmap\" [hidden]=\"hidden\">\r\n  <svg *ngIf=\"graphic\" width=\"100%\" [attr.viewBox]=\"graphic.viewBox\">\r\n    <defs>\r\n      <filter id=\"bd2hm-shadow\">\r\n        <feDropShadow dx=\"1\" dy=\"1\" stdDeviation=\"1\"/>\r\n      </filter>\r\n      <pattern id=\"bd2hm-pattern-diagonal\" width=\"10\" height=\"10\" patternTransform=\"rotate(45 0 0)\"\r\n               patternUnits=\"userSpaceOnUse\">\r\n        <line x1=\"0\" y1=\"0\" x2=\"0\" y2=\"10\" style=\"stroke:lightgrey; stroke-width:1\"/>\r\n      </pattern>\r\n    </defs>\r\n\r\n    <g class=\"bd2hm-mainPane\" [attr.transform]=\"graphic.mainPaneTransform\">\r\n\r\n      <g bd2hm-pane-back [graphic]=\"graphic\" class=\"bd2hm-paneBack\"></g>\r\n\r\n\r\n      <g bd2hm-axis-box [graphic]=\"graphic\"></g>\r\n\r\n\r\n\r\n      <g bd2hm-series-box [graphic]=\"graphic\" [series]=\"series\" class=\"bd2hm-seriesBox\"></g>\r\n\r\n\r\n      <g bd2hm-labels [graphic]=\"graphic\" [data]=\"series\" [alwaysOn]=\"labelsAlwaysOn\"></g>\r\n\r\n      <g bd2hm-tooltip [graphic]=\"graphic\"></g>\r\n    </g>\r\n  </svg>\r\n  <!--{{ series | json }}-->\r\n</div>\r\n", styles: ["::ng-deep .bd2hm-paneBack rect{fill:url(#bd2hm-pattern-diagonal)}::ng-deep .bd2hm-axisWrapper line{stroke:gray}::ng-deep .bd2hm-axisWrapper text{fill:gray;text-anchor:middle;font-size:9px}::ng-deep .bd2hm-labels text.bd2hm-onLabel{dominant-baseline:central;fill:#000;opacity:.6}::ng-deep .bd2hm-labels .bd2hm-hover text{dominant-baseline:central;fill:#fff;font-size:10px}::ng-deep .bd2hm-labels .bd2hm-hover rect{fill:#000;opacity:.8;filter:url(#bd2hm-shadow)}::ng-deep .bd2hm-tooltipBox text{font-size:10px;fill:#fff}::ng-deep .bd2hm-tooltipBox rect{fill:#000;opacity:.8;filter:url(#bd2hm-shadow)}\n"] }]
        }], ctorParameters: function () { return [{ type: i0.ChangeDetectorRef }, { type: TooltipService }]; }, propDecorators: { data: [{
                type: Input
            }], asymmetric: [{
                type: Input
            }], middleZero: [{
                type: Input
            }], hidden: [{
                type: Input
            }], labelsAlwaysOn: [{
                type: Input
            }], lookAndFeel: [{
                type: Input
            }] } });

class AxisModule {
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: AxisModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "16.2.12", ngImport: i0, type: AxisModule, declarations: [AxisBoxComponent,
            NumXAxisComponent,
            YAxisComponent,
            VTickMarkComponent], imports: [CommonModule], exports: [AxisBoxComponent,
            NumXAxisComponent,
            YAxisComponent,
            VTickMarkComponent] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: AxisModule, imports: [CommonModule] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: AxisModule, decorators: [{
            type: NgModule,
            args: [{
                    declarations: [
                        AxisBoxComponent,
                        NumXAxisComponent,
                        YAxisComponent,
                        VTickMarkComponent,
                    ],
                    imports: [
                        CommonModule
                    ],
                    exports: [
                        AxisBoxComponent,
                        NumXAxisComponent,
                        YAxisComponent,
                        VTickMarkComponent,
                    ],
                }]
        }] });

class PlotElementsModule {
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: PlotElementsModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "16.2.12", ngImport: i0, type: PlotElementsModule, declarations: [LabelsComponent,
            LabelBoxComponent,
            TooltipComponent,
            PaneBackComponent,
            SeriesBoxComponent,
            SerieRowComponent,
            DataPointBoxComponent], imports: [CommonModule,
            AxisModule], exports: [LabelsComponent,
            LabelBoxComponent,
            TooltipComponent,
            PaneBackComponent,
            SeriesBoxComponent,
            SerieRowComponent,
            DataPointBoxComponent,
            AxisModule] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: PlotElementsModule, imports: [CommonModule,
            AxisModule, AxisModule] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: PlotElementsModule, decorators: [{
            type: NgModule,
            args: [{
                    declarations: [
                        LabelsComponent,
                        LabelBoxComponent,
                        TooltipComponent,
                        PaneBackComponent,
                        SeriesBoxComponent,
                        SerieRowComponent,
                        DataPointBoxComponent,
                    ],
                    imports: [
                        CommonModule,
                        AxisModule
                    ],
                    exports: [
                        LabelsComponent,
                        LabelBoxComponent,
                        TooltipComponent,
                        PaneBackComponent,
                        SeriesBoxComponent,
                        SerieRowComponent,
                        DataPointBoxComponent,
                        AxisModule
                    ]
                }]
        }] });

class Bd2NumHeatmapModule {
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: Bd2NumHeatmapModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "16.2.12", ngImport: i0, type: Bd2NumHeatmapModule, declarations: [Bd2NumHeatmapComponent], imports: [CommonModule,
            PlotElementsModule], exports: [Bd2NumHeatmapComponent] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: Bd2NumHeatmapModule, imports: [CommonModule,
            PlotElementsModule] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: Bd2NumHeatmapModule, decorators: [{
            type: NgModule,
            args: [{
                    declarations: [Bd2NumHeatmapComponent],
                    imports: [
                        CommonModule,
                        PlotElementsModule
                    ],
                    exports: [Bd2NumHeatmapComponent]
                }]
        }] });

class Bd2NgxHeatmapModule {
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: Bd2NgxHeatmapModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "16.2.12", ngImport: i0, type: Bd2NgxHeatmapModule, imports: [Bd2NumHeatmapModule], exports: [Bd2NumHeatmapComponent] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: Bd2NgxHeatmapModule, imports: [Bd2NumHeatmapModule] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: Bd2NgxHeatmapModule, decorators: [{
            type: NgModule,
            args: [{
                    declarations: [],
                    imports: [
                        Bd2NumHeatmapModule
                    ],
                    exports: [Bd2NumHeatmapComponent]
                }]
        }] });

/*
 * Public API Surface of bd2-ngx-heatmap
 */

/**
 * Generated bundle index. Do not edit.
 */

export { Bd2NgxHeatmapModule, Bd2NumHeatmapComponent, BoxDef, BoxSerie, GraphicContext, LookAndFeelSizing, Tick };
//# sourceMappingURL=bd2-ngx-heatmap.mjs.map
