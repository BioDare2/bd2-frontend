import { ChangeDetectionStrategy, Component, Input } from '@angular/core';
import { Tick } from '../../../../bd2-heatmap.dom';
import * as i0 from "@angular/core";
import * as i1 from "@angular/common";
import * as i2 from "./v-tick-mark/v-tick-mark.component";
//
export class NumXAxisComponent {
    constructor() {
        this.top = false;
        this.ticks = [];
    }
    trackByIndex(index, item) {
        return index;
    }
    ngOnInit() {
    }
    ngOnChanges(changes) {
        this.axisTransform = `translate(0,${this.yPosition})`;
        this.x2 = this.xScale?.range()[1];
        this.ticks = this.prepareTicks(this.xScale);
    }
    prepareTicks(xScale) {
        const positions = this.calculateTicksPosition(xScale);
        return positions.map(tick => new Tick(xScale(tick), 0, tick, this.top, false));
    }
    calculateTicksPosition(xScale) {
        if (!xScale) {
            return [];
        }
        const ticks = [];
        const domain = this.xDomain || xScale.domain();
        const first = Math.round(domain[0]);
        const last = Math.round(domain[1]);
        const step = this.domainStep(last - first);
        for (let i = first; i <= last; i += step) {
            ticks.push(i);
        }
        return ticks;
    }
    domainStep(range) {
        if (range <= 25) {
            return 4;
        }
        if (range <= 73) {
            return 6;
        }
        if (range <= 169) {
            return 12;
        }
        return 24;
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: NumXAxisComponent, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: NumXAxisComponent, selector: "[bd2hm-num-x-axis]", inputs: { xScale: "xScale", xDomain: "xDomain", yPosition: "yPosition", top: "top" }, usesOnChanges: true, ngImport: i0, template: `
    <svg:g class="bd2hm-x-axis" [attr.transform]="axisTransform" >
      <svg:line x1="0" y1="0" y2="0" [attr.x2]="x2"></svg:line>
      <svg:g *ngFor="let tick of ticks; trackBy: trackByIndex" bd2hm-vtick-mark class="bd2hm-tickMark" [tick]="tick"></svg:g>
    </svg:g>
  `, isInline: true, dependencies: [{ kind: "directive", type: i1.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "component", type: i2.VTickMarkComponent, selector: "[bd2hm-vtick-mark]", inputs: ["tick", "length"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: NumXAxisComponent, decorators: [{
            type: Component,
            args: [{ selector: '[bd2hm-num-x-axis]', template: `
    <svg:g class="bd2hm-x-axis" [attr.transform]="axisTransform" >
      <svg:line x1="0" y1="0" y2="0" [attr.x2]="x2"></svg:line>
      <svg:g *ngFor="let tick of ticks; trackBy: trackByIndex" bd2hm-vtick-mark class="bd2hm-tickMark" [tick]="tick"></svg:g>
    </svg:g>
  `, changeDetection: ChangeDetectionStrategy.OnPush }]
        }], ctorParameters: function () { return []; }, propDecorators: { xScale: [{
                type: Input
            }], xDomain: [{
                type: Input
            }], yPosition: [{
                type: Input
            }], top: [{
                type: Input
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibnVtLXgtYXhpcy5jb21wb25lbnQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi9wcm9qZWN0cy9iZDItbmd4LWhlYXRtYXAvc3JjL2xpYi9wbG90LWVsZW1lbnRzL2F4aXMvYXhpcy1ib3gveC1heGlzL251bS14LWF4aXMuY29tcG9uZW50LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBQyx1QkFBdUIsRUFBRSxTQUFTLEVBQUUsS0FBSyxFQUFtQyxNQUFNLGVBQWUsQ0FBQztBQUUxRyxPQUFPLEVBQUMsSUFBSSxFQUFDLE1BQU0sNkJBQTZCLENBQUM7Ozs7QUFFakQsRUFBRTtBQWFGLE1BQU0sT0FBTyxpQkFBaUI7SUFrQjVCO1FBTkEsUUFBRyxHQUFHLEtBQUssQ0FBQztRQUlaLFVBQUssR0FBVyxFQUFFLENBQUM7SUFHbkIsQ0FBQztJQUVELFlBQVksQ0FBQyxLQUFhLEVBQUUsSUFBUztRQUNuQyxPQUFPLEtBQUssQ0FBQztJQUNmLENBQUM7SUFHRCxRQUFRO0lBQ1IsQ0FBQztJQUVELFdBQVcsQ0FBQyxPQUFzQjtRQUVoQyxJQUFJLENBQUMsYUFBYSxHQUFHLGVBQWUsSUFBSSxDQUFDLFNBQVMsR0FBRyxDQUFDO1FBQ3RELElBQUksQ0FBQyxFQUFFLEdBQUcsSUFBSSxDQUFDLE1BQU0sRUFBRSxLQUFLLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUNsQyxJQUFJLENBQUMsS0FBSyxHQUFHLElBQUksQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDO0lBQzlDLENBQUM7SUFHRCxZQUFZLENBQUMsTUFBbUM7UUFDOUMsTUFBTSxTQUFTLEdBQUcsSUFBSSxDQUFDLHNCQUFzQixDQUFDLE1BQU0sQ0FBQyxDQUFDO1FBRXRELE9BQU8sU0FBUyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLElBQUksSUFBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLEVBQUUsSUFBSSxFQUFFLElBQUksQ0FBQyxHQUFHLEVBQUUsS0FBSyxDQUFDLENBQUMsQ0FBQztJQUNqRixDQUFDO0lBSUQsc0JBQXNCLENBQUMsTUFBbUM7UUFDeEQsSUFBSSxDQUFDLE1BQU0sRUFBRTtZQUNYLE9BQU8sRUFBRSxDQUFDO1NBQ1g7UUFDRCxNQUFNLEtBQUssR0FBRyxFQUFFLENBQUM7UUFDakIsTUFBTSxNQUFNLEdBQUcsSUFBSSxDQUFDLE9BQU8sSUFBSSxNQUFNLENBQUMsTUFBTSxFQUFFLENBQUM7UUFDL0MsTUFBTSxLQUFLLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUNwQyxNQUFNLElBQUksR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ25DLE1BQU0sSUFBSSxHQUFHLElBQUksQ0FBQyxVQUFVLENBQUMsSUFBSSxHQUFHLEtBQUssQ0FBQyxDQUFDO1FBQzNDLEtBQUssSUFBSSxDQUFDLEdBQUcsS0FBSyxFQUFFLENBQUMsSUFBSSxJQUFJLEVBQUUsQ0FBQyxJQUFJLElBQUksRUFBRTtZQUN4QyxLQUFLLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDO1NBQ2Y7UUFDRCxPQUFPLEtBQUssQ0FBQztJQUNmLENBQUM7SUFFRCxVQUFVLENBQUMsS0FBYTtRQUN0QixJQUFJLEtBQUssSUFBSSxFQUFFLEVBQUU7WUFDZixPQUFPLENBQUMsQ0FBQztTQUNWO1FBQ0QsSUFBSSxLQUFLLElBQUksRUFBRSxFQUFFO1lBQ2YsT0FBTyxDQUFDLENBQUM7U0FDVjtRQUNELElBQUksS0FBSyxJQUFJLEdBQUcsRUFBRTtZQUNoQixPQUFPLEVBQUUsQ0FBQztTQUNYO1FBQ0QsT0FBTyxFQUFFLENBQUM7SUFDWixDQUFDOytHQXZFVSxpQkFBaUI7bUdBQWpCLGlCQUFpQixxS0FUbEI7Ozs7O0dBS1Q7OzRGQUlVLGlCQUFpQjtrQkFYN0IsU0FBUzsrQkFDRSxvQkFBb0IsWUFDcEI7Ozs7O0dBS1QsbUJBRWdCLHVCQUF1QixDQUFDLE1BQU07MEVBSy9DLE1BQU07c0JBREwsS0FBSztnQkFJTixPQUFPO3NCQUROLEtBQUs7Z0JBSU4sU0FBUztzQkFEUixLQUFLO2dCQUlOLEdBQUc7c0JBREYsS0FBSyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7Q2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3ksIENvbXBvbmVudCwgSW5wdXQsIE9uQ2hhbmdlcywgT25Jbml0LCBTaW1wbGVDaGFuZ2VzfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHtTY2FsZUxpbmVhcn0gZnJvbSAnZDMtc2NhbGUnO1xyXG5pbXBvcnQge1RpY2t9IGZyb20gJy4uLy4uLy4uLy4uL2JkMi1oZWF0bWFwLmRvbSc7XHJcblxyXG4vL1xyXG5cclxuQENvbXBvbmVudCh7XHJcbiAgc2VsZWN0b3I6ICdbYmQyaG0tbnVtLXgtYXhpc10nLFxyXG4gIHRlbXBsYXRlOiBgXHJcbiAgICA8c3ZnOmcgY2xhc3M9XCJiZDJobS14LWF4aXNcIiBbYXR0ci50cmFuc2Zvcm1dPVwiYXhpc1RyYW5zZm9ybVwiID5cclxuICAgICAgPHN2ZzpsaW5lIHgxPVwiMFwiIHkxPVwiMFwiIHkyPVwiMFwiIFthdHRyLngyXT1cIngyXCI+PC9zdmc6bGluZT5cclxuICAgICAgPHN2ZzpnICpuZ0Zvcj1cImxldCB0aWNrIG9mIHRpY2tzOyB0cmFja0J5OiB0cmFja0J5SW5kZXhcIiBiZDJobS12dGljay1tYXJrIGNsYXNzPVwiYmQyaG0tdGlja01hcmtcIiBbdGlja109XCJ0aWNrXCI+PC9zdmc6Zz5cclxuICAgIDwvc3ZnOmc+XHJcbiAgYCxcclxuICBzdHlsZXM6IFtdLFxyXG4gIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoXHJcbn0pXHJcbmV4cG9ydCBjbGFzcyBOdW1YQXhpc0NvbXBvbmVudCBpbXBsZW1lbnRzIE9uSW5pdCwgT25DaGFuZ2VzIHtcclxuXHJcbiAgQElucHV0KClcclxuICB4U2NhbGU6IFNjYWxlTGluZWFyPG51bWJlciwgbnVtYmVyPjtcclxuXHJcbiAgQElucHV0KClcclxuICB4RG9tYWluOiBbbnVtYmVyLCBudW1iZXJdO1xyXG5cclxuICBASW5wdXQoKVxyXG4gIHlQb3NpdGlvbjogbnVtYmVyO1xyXG5cclxuICBASW5wdXQoKVxyXG4gIHRvcCA9IGZhbHNlO1xyXG5cclxuICBheGlzVHJhbnNmb3JtOiBzdHJpbmc7XHJcbiAgeDI6IG51bWJlcjtcclxuICB0aWNrczogVGlja1tdID0gW107XHJcblxyXG4gIGNvbnN0cnVjdG9yKCkge1xyXG4gIH1cclxuXHJcbiAgdHJhY2tCeUluZGV4KGluZGV4OiBudW1iZXIsIGl0ZW06IGFueSkge1xyXG4gICAgcmV0dXJuIGluZGV4O1xyXG4gIH1cclxuXHJcblxyXG4gIG5nT25Jbml0KCk6IHZvaWQge1xyXG4gIH1cclxuXHJcbiAgbmdPbkNoYW5nZXMoY2hhbmdlczogU2ltcGxlQ2hhbmdlcyk6IHZvaWQge1xyXG5cclxuICAgIHRoaXMuYXhpc1RyYW5zZm9ybSA9IGB0cmFuc2xhdGUoMCwke3RoaXMueVBvc2l0aW9ufSlgO1xyXG4gICAgdGhpcy54MiA9IHRoaXMueFNjYWxlPy5yYW5nZSgpWzFdO1xyXG4gICAgdGhpcy50aWNrcyA9IHRoaXMucHJlcGFyZVRpY2tzKHRoaXMueFNjYWxlKTtcclxuICB9XHJcblxyXG5cclxuICBwcmVwYXJlVGlja3MoeFNjYWxlOiBTY2FsZUxpbmVhcjxudW1iZXIsIG51bWJlcj4pOiBUaWNrW10ge1xyXG4gICAgY29uc3QgcG9zaXRpb25zID0gdGhpcy5jYWxjdWxhdGVUaWNrc1Bvc2l0aW9uKHhTY2FsZSk7XHJcblxyXG4gICAgcmV0dXJuIHBvc2l0aW9ucy5tYXAodGljayA9PiBuZXcgVGljayh4U2NhbGUodGljayksIDAsIHRpY2ssIHRoaXMudG9wLCBmYWxzZSkpO1xyXG4gIH1cclxuXHJcblxyXG5cclxuICBjYWxjdWxhdGVUaWNrc1Bvc2l0aW9uKHhTY2FsZTogU2NhbGVMaW5lYXI8bnVtYmVyLCBudW1iZXI+KSB7XHJcbiAgICBpZiAoIXhTY2FsZSkge1xyXG4gICAgICByZXR1cm4gW107XHJcbiAgICB9XHJcbiAgICBjb25zdCB0aWNrcyA9IFtdO1xyXG4gICAgY29uc3QgZG9tYWluID0gdGhpcy54RG9tYWluIHx8IHhTY2FsZS5kb21haW4oKTtcclxuICAgIGNvbnN0IGZpcnN0ID0gTWF0aC5yb3VuZChkb21haW5bMF0pO1xyXG4gICAgY29uc3QgbGFzdCA9IE1hdGgucm91bmQoZG9tYWluWzFdKTtcclxuICAgIGNvbnN0IHN0ZXAgPSB0aGlzLmRvbWFpblN0ZXAobGFzdCAtIGZpcnN0KTtcclxuICAgIGZvciAobGV0IGkgPSBmaXJzdDsgaSA8PSBsYXN0OyBpICs9IHN0ZXApIHtcclxuICAgICAgdGlja3MucHVzaChpKTtcclxuICAgIH1cclxuICAgIHJldHVybiB0aWNrcztcclxuICB9XHJcblxyXG4gIGRvbWFpblN0ZXAocmFuZ2U6IG51bWJlcikge1xyXG4gICAgaWYgKHJhbmdlIDw9IDI1KSB7XHJcbiAgICAgIHJldHVybiA0O1xyXG4gICAgfVxyXG4gICAgaWYgKHJhbmdlIDw9IDczKSB7XHJcbiAgICAgIHJldHVybiA2O1xyXG4gICAgfVxyXG4gICAgaWYgKHJhbmdlIDw9IDE2OSkge1xyXG4gICAgICByZXR1cm4gMTI7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gMjQ7XHJcbiAgfVxyXG5cclxufVxyXG4iXX0=