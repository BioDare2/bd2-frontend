import { ChangeDetectionStrategy, Component, Input, ViewChild } from '@angular/core';
import { timer } from 'rxjs';
import { map, tap } from 'rxjs/operators';
import * as i0 from "@angular/core";
import * as i1 from "@angular/common";
export class LabelBoxComponent {
    constructor(changeDetector) {
        this.changeDetector = changeDetector;
        this.alwaysOn = true;
        this.color = 'rgb(67, 125, 179)';
        this.textBWidth = 0;
        this.textBY = 0;
        this.toggled = false;
        this.ready = false;
    }
    ngOnInit() {
    }
    ngOnChanges(changes) {
        this.margin = this.marginSize();
        this.triggerY = this.yStart + this.margin;
        this.triggerHeight = this.margin > 1 ? this.maxHeight - 2 * this.margin : this.maxHeight - 1;
        this.yMiddle = this.yStart + this.maxHeight / 2;
    }
    marginSize() {
        if (this.maxHeight >= 20) {
            return 4;
        }
        if (this.maxHeight >= 12) {
            return 2;
        }
        return 1;
    }
    fontSize() {
        if (this.maxHeight > 12) {
            return 10;
        }
        if (this.maxHeight >= 6) {
            return this.maxHeight - 3;
        }
        return 0;
    }
    toggleLabel(val) {
        if (val === undefined) {
            val = !this.toggled;
        }
        this.ready = false;
        this.toggled = val;
        if (this.toggled) {
            this.updateTextBBox().subscribe(rect => {
                if (this.toggled) {
                    this.ready = true;
                }
                this.changeDetector.markForCheck();
            });
        }
    }
    updateTextBBox() {
        return timer(0).pipe(map(r => this.textBBox()), tap(rect => this.setTextBBox(rect)));
    }
    setTextBBox(rect) {
        this.textBY = rect.y - 4;
        this.textBHeight = rect.height + 8;
        this.textBWidth = rect.x + rect.width + 4;
    }
    textBBox() {
        if (!this.textNode) {
            return { x: 0, y: 0, height: 0, width: 0 };
        }
        return this.textNode.nativeElement.getBBox();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: LabelBoxComponent, deps: [{ token: i0.ChangeDetectorRef }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: LabelBoxComponent, selector: "[bd2hm-label-box]", inputs: { serie: "serie", yStart: "yStart", maxHeight: "maxHeight", alwaysOn: "alwaysOn", color: "color" }, viewQueries: [{ propertyName: "textNode", first: true, predicate: ["text"], descendants: true }], usesOnChanges: true, ngImport: i0, template: `
    <svg:g *ngIf="serie" class="bd2hm-label">
      <svg:text *ngIf="alwaysOn" x="5" [attr.y]="yMiddle" class="bd2hm-onLabel"
                [attr.font-size]="fontSize()"
      >{{serie.label}}</svg:text>

      <g (mouseout)="toggleLabel(false)" (mouseover)="toggleLabel(true)">
        <svg:rect x="-7" width="7" [attr.y]="triggerY" [attr.height]="triggerHeight" [attr.fill]="color"
        ></svg:rect>

        <!--<svg:circle [attr.cx]="-cirR()-2" [attr.cy]="yMiddle" [attr.r]="cirR()" [attr.fill]="'rgb(67, 125, 179)'"
                    [attr.filter]="band < 7 ? undefined : 'url(#bd2hm-shadow)'"
        ></svg:circle>-->

        <svg:g class="bd2hm-hover" [attr.opacity]="ready ? 1 : 0" [attr.display]="toggled ? undefined : 'none'">
          <svg:rect x="0" [attr.width]="textBWidth" [attr.y]="textBY" [attr.height]="textBHeight"
          ></svg:rect>
          <svg:text #text x="5" [attr.y]="yMiddle"
          >{{serie.label}}</svg:text>
        </svg:g>
      </g>
    </svg:g>
  `, isInline: true, dependencies: [{ kind: "directive", type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: LabelBoxComponent, decorators: [{
            type: Component,
            args: [{ selector: '[bd2hm-label-box]', template: `
    <svg:g *ngIf="serie" class="bd2hm-label">
      <svg:text *ngIf="alwaysOn" x="5" [attr.y]="yMiddle" class="bd2hm-onLabel"
                [attr.font-size]="fontSize()"
      >{{serie.label}}</svg:text>

      <g (mouseout)="toggleLabel(false)" (mouseover)="toggleLabel(true)">
        <svg:rect x="-7" width="7" [attr.y]="triggerY" [attr.height]="triggerHeight" [attr.fill]="color"
        ></svg:rect>

        <!--<svg:circle [attr.cx]="-cirR()-2" [attr.cy]="yMiddle" [attr.r]="cirR()" [attr.fill]="'rgb(67, 125, 179)'"
                    [attr.filter]="band < 7 ? undefined : 'url(#bd2hm-shadow)'"
        ></svg:circle>-->

        <svg:g class="bd2hm-hover" [attr.opacity]="ready ? 1 : 0" [attr.display]="toggled ? undefined : 'none'">
          <svg:rect x="0" [attr.width]="textBWidth" [attr.y]="textBY" [attr.height]="textBHeight"
          ></svg:rect>
          <svg:text #text x="5" [attr.y]="yMiddle"
          >{{serie.label}}</svg:text>
        </svg:g>
      </g>
    </svg:g>
  `, changeDetection: ChangeDetectionStrategy.OnPush }]
        }], ctorParameters: function () { return [{ type: i0.ChangeDetectorRef }]; }, propDecorators: { serie: [{
                type: Input
            }], yStart: [{
                type: Input
            }], maxHeight: [{
                type: Input
            }], alwaysOn: [{
                type: Input
            }], color: [{
                type: Input
            }], textNode: [{
                type: ViewChild,
                args: ['text']
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibGFiZWwtYm94LmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL2JkMi1uZ3gtaGVhdG1hcC9zcmMvbGliL3Bsb3QtZWxlbWVudHMvbGFiZWxzL2xhYmVsLWJveC9sYWJlbC1ib3guY29tcG9uZW50LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFDTCx1QkFBdUIsRUFFdkIsU0FBUyxFQUVULEtBQUssRUFJTCxTQUFTLEVBQ1YsTUFBTSxlQUFlLENBQUM7QUFFdkIsT0FBTyxFQUFhLEtBQUssRUFBQyxNQUFNLE1BQU0sQ0FBQztBQUN2QyxPQUFPLEVBQUMsR0FBRyxFQUFFLEdBQUcsRUFBQyxNQUFNLGdCQUFnQixDQUFDOzs7QUE4QnhDLE1BQU0sT0FBTyxpQkFBaUI7SUFrQzVCLFlBQW9CLGNBQWlDO1FBQWpDLG1CQUFjLEdBQWQsY0FBYyxDQUFtQjtRQXRCckQsYUFBUSxHQUFHLElBQUksQ0FBQztRQUdoQixVQUFLLEdBQUcsbUJBQW1CLENBQUM7UUFZNUIsZUFBVSxHQUFHLENBQUMsQ0FBQztRQUNmLFdBQU0sR0FBRyxDQUFDLENBQUM7UUFHWCxZQUFPLEdBQUcsS0FBSyxDQUFDO1FBQ2hCLFVBQUssR0FBRyxLQUFLLENBQUM7SUFHZCxDQUFDO0lBRUQsUUFBUTtJQUNSLENBQUM7SUFFRCxXQUFXLENBQUMsT0FBc0I7UUFDaEMsSUFBSSxDQUFDLE1BQU0sR0FBRyxJQUFJLENBQUMsVUFBVSxFQUFFLENBQUM7UUFDaEMsSUFBSSxDQUFDLFFBQVEsR0FBRyxJQUFJLENBQUMsTUFBTSxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUM7UUFDMUMsSUFBSSxDQUFDLGFBQWEsR0FBRyxJQUFJLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLFNBQVMsR0FBRyxDQUFDLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsSUFB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QkFXTixRQUFRO3NCQURQLFNBQVM7dUJBQUMsTUFBTSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XHJcbiAgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3ksXHJcbiAgQ2hhbmdlRGV0ZWN0b3JSZWYsXHJcbiAgQ29tcG9uZW50LFxyXG4gIEVsZW1lbnRSZWYsXHJcbiAgSW5wdXQsXHJcbiAgT25DaGFuZ2VzLFxyXG4gIE9uSW5pdCxcclxuICBTaW1wbGVDaGFuZ2VzLFxyXG4gIFZpZXdDaGlsZFxyXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQge1NlcmllfSBmcm9tICcuLi8uLi8uLi9iZDItaGVhdG1hcC5kb20nO1xyXG5pbXBvcnQge09ic2VydmFibGUsIHRpbWVyfSBmcm9tICdyeGpzJztcclxuaW1wb3J0IHttYXAsIHRhcH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xyXG5cclxuQENvbXBvbmVudCh7XHJcbiAgc2VsZWN0b3I6ICdbYmQyaG0tbGFiZWwtYm94XScsXHJcbiAgdGVtcGxhdGU6IGBcclxuICAgIDxzdmc6ZyAqbmdJZj1cInNlcmllXCIgY2xhc3M9XCJiZDJobS1sYWJlbFwiPlxyXG4gICAgICA8c3ZnOnRleHQgKm5nSWY9XCJhbHdheXNPblwiIHg9XCI1XCIgW2F0dHIueV09XCJ5TWlkZGxlXCIgY2xhc3M9XCJiZDJobS1vbkxhYmVsXCJcclxuICAgICAgICAgICAgICAgIFthdHRyLmZvbnQtc2l6ZV09XCJmb250U2l6ZSgpXCJcclxuICAgICAgPnt7c2VyaWUubGFiZWx9fTwvc3ZnOnRleHQ+XHJcblxyXG4gICAgICA8ZyAobW91c2VvdXQpPVwidG9nZ2xlTGFiZWwoZmFsc2UpXCIgKG1vdXNlb3Zlcik9XCJ0b2dnbGVMYWJlbCh0cnVlKVwiPlxyXG4gICAgICAgIDxzdmc6cmVjdCB4PVwiLTdcIiB3aWR0aD1cIjdcIiBbYXR0ci55XT1cInRyaWdnZXJZXCIgW2F0dHIuaGVpZ2h0XT1cInRyaWdnZXJIZWlnaHRcIiBbYXR0ci5maWxsXT1cImNvbG9yXCJcclxuICAgICAgICA+PC9zdmc6cmVjdD5cclxuXHJcbiAgICAgICAgPCEtLTxzdmc6Y2lyY2xlIFthdHRyLmN4XT1cIi1jaXJSKCktMlwiIFthdHRyLmN5XT1cInlNaWRkbGVcIiBbYXR0ci5yXT1cImNpclIoKVwiIFthdHRyLmZpbGxdPVwiJ3JnYig2NywgMTI1LCAxNzkpJ1wiXHJcbiAgICAgICAgICAgICAgICAgICAgW2F0dHIuZmlsdGVyXT1cImJhbmQgPCA3ID8gdW5kZWZpbmVkIDogJ3VybCgjYmQyaG0tc2hhZG93KSdcIlxyXG4gICAgICAgID48L3N2ZzpjaXJjbGU+LS0+XHJcblxyXG4gICAgICAgIDxzdmc6ZyBjbGFzcz1cImJkMmhtLWhvdmVyXCIgW2F0dHIub3BhY2l0eV09XCJyZWFkeSA/IDEgOiAwXCIgW2F0dHIuZGlzcGxheV09XCJ0b2dnbGVkID8gdW5kZWZpbmVkIDogJ25vbmUnXCI+XHJcbiAgICAgICAgICA8c3ZnOnJlY3QgeD1cIjBcIiBbYXR0ci53aWR0aF09XCJ0ZXh0QldpZHRoXCIgW2F0dHIueV09XCJ0ZXh0QllcIiBbYXR0ci5oZWlnaHRdPVwidGV4dEJIZWlnaHRcIlxyXG4gICAgICAgICAgPjwvc3ZnOnJlY3Q+XHJcbiAgICAgICAgICA8c3ZnOnRleHQgI3RleHQgeD1cIjVcIiBbYXR0ci55XT1cInlNaWRkbGVcIlxyXG4gICAgICAgICAgPnt7c2VyaWUubGFiZWx9fTwvc3ZnOnRleHQ+XHJcbiAgICAgICAgPC9zdmc6Zz5cclxuICAgICAgPC9nPlxyXG4gICAgPC9zdmc6Zz5cclxuICBgLFxyXG4gIHN0eWxlczogW10sXHJcbiAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2hcclxufSlcclxuZXhwb3J0IGNsYXNzIExhYmVsQm94Q29tcG9uZW50IGltcGxlbWVudHMgT25Jbml0LCBPbkNoYW5nZXMge1xyXG5cclxuICBASW5wdXQoKVxyXG4gIHNlcmllOiBTZXJpZTtcclxuXHJcbiAgQElucHV0KClcclxuICB5U3RhcnQ6IG51bWJlcjtcclxuXHJcbiAgQElucHV0KClcclxuICBtYXhIZWlnaHQ6IG51bWJlcjtcclxuXHJcbiAgQElucHV0KClcclxuICBhbHdheXNPbiA9IHRydWU7XHJcblxyXG4gIEBJbnB1dCgpXHJcbiAgY29sb3IgPSAncmdiKDY3LCAxMjUsIDE3OSknO1xyXG5cclxuICBtYXJnaW46IG51bWJlcjtcclxuICB0cmlnZ2VyWTogbnVtYmVyO1xyXG4gIHRyaWdnZXJIZWlnaHQ6IG51bWJlcjtcclxuXHJcbiAgeU1pZGRsZTogbnVtYmVyO1xyXG5cclxuXHJcbiAgQFZpZXdDaGlsZCgndGV4dCcpXHJcbiAgdGV4dE5vZGU6IEVsZW1lbnRSZWY8U1ZHR3JhcGhpY3NFbGVtZW50PjtcclxuXHJcbiAgdGV4dEJXaWR0aCA9IDA7XHJcbiAgdGV4dEJZID0gMDtcclxuICB0ZXh0QkhlaWdodDtcclxuXHJcbiAgdG9nZ2xlZCA9IGZhbHNlO1xyXG4gIHJlYWR5ID0gZmFsc2U7XHJcblxyXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgY2hhbmdlRGV0ZWN0b3I6IENoYW5nZURldGVjdG9yUmVmKSB7XHJcbiAgfVxyXG5cclxuICBuZ09uSW5pdCgpOiB2b2lkIHtcclxuICB9XHJcblxyXG4gIG5nT25DaGFuZ2VzKGNoYW5nZXM6IFNpbXBsZUNoYW5nZXMpOiB2b2lkIHtcclxuICAgIHRoaXMubWFyZ2luID0gdGhpcy5tYXJnaW5TaXplKCk7XHJcbiAgICB0aGlzLnRyaWdnZXJZID0gdGhpcy55U3RhcnQgKyB0aGlzLm1hcmdpbjtcclxuICAgIHRoaXMudHJpZ2dlckhlaWdodCA9IHRoaXMubWFyZ2luID4gMSA/IHRoaXMubWF4SGVpZ2h0IC0gMiAqIHRoaXMubWFyZ2luIDogdGhpcy5tYXhIZWlnaHQgLSAxO1xyXG4gICAgdGhpcy55TWlkZGxlID0gdGhpcy55U3RhcnQgKyB0aGlzLm1heEhlaWdodCAvIDI7XHJcblxyXG4gIH1cclxuXHJcbiAgbWFyZ2luU2l6ZSgpIHtcclxuICAgIGlmICh0aGlzLm1heEhlaWdodCA+PSAyMCkge1xyXG4gICAgICByZXR1cm4gNDtcclxuICAgIH1cclxuICAgIGlmICh0aGlzLm1heEhlaWdodCA+PSAxMikge1xyXG4gICAgICByZXR1cm4gMjtcclxuICAgIH1cclxuICAgIHJldHVybiAxO1xyXG4gIH1cclxuXHJcbiAgZm9udFNpemUoKSB7XHJcbiAgICBpZiAodGhpcy5tYXhIZWlnaHQgPiAxMikge1xyXG4gICAgICByZXR1cm4gMTA7XHJcbiAgICB9XHJcbiAgICBpZiAodGhpcy5tYXhIZWlnaHQgPj0gNikge1xyXG4gICAgICByZXR1cm4gdGhpcy5tYXhIZWlnaHQgLSAzO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIDA7XHJcbiAgfVxyXG5cclxuICB0b2dnbGVMYWJlbCh2YWw/OiBib29sZWFuKSB7XHJcblxyXG4gICAgaWYgKHZhbCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIHZhbCA9ICF0aGlzLnRvZ2dsZWQ7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5yZWFkeSA9IGZhbHNlO1xyXG4gICAgdGhpcy50b2dnbGVkID0gdmFsO1xyXG5cclxuICAgIGlmICh0aGlzLnRvZ2dsZWQpIHtcclxuICAgICAgdGhpcy51cGRhdGVUZXh0QkJveCgpLnN1YnNjcmliZShcclxuICAgICAgICByZWN0ID0+IHtcclxuICAgICAgICAgIGlmICh0aGlzLnRvZ2dsZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5yZWFkeSA9IHRydWU7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICB0aGlzLmNoYW5nZURldGVjdG9yLm1hcmtGb3JDaGVjaygpO1xyXG4gICAgICAgIH1cclxuICAgICAgKTtcclxuICAgIH1cclxuXHJcbiAgfVxyXG5cclxuICB1cGRhdGVUZXh0QkJveCgpOiBPYnNlcnZhYmxlPFNWR1JlY3Q+IHtcclxuXHJcbiAgICByZXR1cm4gdGltZXIoMCkucGlwZShcclxuICAgICAgbWFwKHIgPT4gdGhpcy50ZXh0QkJveCgpKSxcclxuICAgICAgdGFwKHJlY3QgPT4gdGhpcy5zZXRUZXh0QkJveChyZWN0KSlcclxuICAgICk7XHJcbiAgfVxyXG5cclxuICBzZXRUZXh0QkJveChyZWN0OiBTVkdSZWN0KSB7XHJcbiAgICB0aGlzLnRleHRCWSA9IHJlY3QueSAtIDQ7XHJcbiAgICB0aGlzLnRleHRCSGVpZ2h0ID0gcmVjdC5oZWlnaHQgKyA4O1xyXG4gICAgdGhpcy50ZXh0QldpZHRoID0gcmVjdC54ICsgcmVjdC53aWR0aCArIDQ7XHJcbiAgfVxyXG5cclxuICB0ZXh0QkJveCgpOiBTVkdSZWN0IHtcclxuICAgIGlmICghdGhpcy50ZXh0Tm9kZSkge1xyXG4gICAgICByZXR1cm4ge3g6IDAsIHk6IDAsIGhlaWdodDogMCwgd2lkdGg6IDB9IGFzIFNWR1JlY3Q7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGhpcy50ZXh0Tm9kZS5uYXRpdmVFbGVtZW50LmdldEJCb3goKTtcclxuICB9XHJcblxyXG4gIC8qXHJcbiAgY2lyUigpIHtcclxuICAgIGlmICh0aGlzLmJhbmQgPj0gMjApIHsgcmV0dXJuIDk7IH1cclxuICAgIGlmICh0aGlzLmJhbmQgPD0gNSApIHsgcmV0dXJuIDI7IH1cclxuICAgIHJldHVybiB0aGlzLmJhbmQgLyAyIC0gMTtcclxuICB9ICovXHJcblxyXG5cclxufVxyXG4iXX0=