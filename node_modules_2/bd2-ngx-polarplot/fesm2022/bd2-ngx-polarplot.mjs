import * as i0 from '@angular/core';
import { EventEmitter, Component, ChangeDetectionStrategy, Input, Output, NgModule } from '@angular/core';
import * as d3 from 'd3';

class PolarPoint {
    constructor(xy, color, hidden) {
        this.xy = xy;
        this.color = color;
        this.hidden = hidden;
    }
}
class PetalNode {
    constructor() {
        this.individuals = [];
    }
}

class SmartRounder {
    static round(value, base) {
        base = base || value;
        base = Math.abs(base);
        if (base < 0.01) {
            return value;
        }
        if (base < 1) {
            return Math.round(value * 10000) / 10000;
        }
        if (base < 1000) {
            return Math.round(value * 100) / 100;
        }
        return Math.round(value);
    }
}

const DEF_ERR = 0.6 / 24;
const DEF_WIDTH = 0.6 / 24;
const MIN_WIDTH = 0.1 / 24;
const NEGLIGIBLE_ERROR = 0.5 / 24;
const MAX_ERROR = 0.33; // 8/24
class PolarDomainUtil {
    dataToPetals(dataGroups, domain, scaleRadius, scaleWidth, errors) {
        if (!dataGroups) {
            return [];
        }
        domain[2] = domain[1] - domain[0];
        return dataGroups.map((g, ix) => this.dataToPetal(g, domain, scaleRadius, scaleWidth, errors ? errors[ix] : null));
    }
    dataToPetal(data, domain, scaleRadius, scaleWidth, error) {
        const node = this.calculatePetalProperties(data, domain, scaleRadius, scaleWidth, error);
        node.polarAngle = this.calculatePolarAngle(node.peak, domain);
        node.petalPath = this.calculatePetalPath(node.peak, node.width, node.radiusScale, domain);
        node.polarCoordinates = this.calculatePolarCoordinate(node.peak, domain);
        // shift back after normalization
        node.peak = node.peak + domain[0];
        node.individuals = this.dataToPolarPoint(data, domain);
        return node;
    }
    dataToPolarPoint(data, domain) {
        const ind = data.map(a => {
            const v = new PolarPoint(this.calculatePolarCoordinate(a, domain), undefined);
            return v;
        });
        return ind;
    }
    calculateCircularMeanAndDev(data, domain) {
        data = data.map(v => this.normalize(v, domain));
        const m = d3.mean(data);
        const std = d3.deviation(data) || 0;
        const rot = domain[2] / 2;
        data = data.map(v => v < rot ? v + domain[2] : v);
        const rotM = d3.mean(data) % domain[2];
        const rotStd = d3.deviation(data) || 0;
        if (rotStd < std) {
            return [rotM, rotStd];
        }
        else {
            return [m, std];
        }
    }
    calculatePetalProperties(data, domain, scaleRadius, scaleWidth, error) {
        const node = new PetalNode();
        const meanStd = this.calculateCircularMeanAndDev(data, domain);
        node.peak = meanStd[0];
        node.roundedPeak = SmartRounder.round(node.peak);
        if ((scaleRadius || scaleWidth) && !error) {
            error = meanStd[1];
        }
        node.width = scaleWidth ? error : DEF_WIDTH * domain[2];
        if (node.width < MIN_WIDTH * domain[2]) {
            node.width = MIN_WIDTH * domain[2];
        }
        if (node.width > domain[2] / 2) {
            node.width = domain[2] / 2;
        }
        node.radiusScale = 1;
        if (scaleRadius) {
            error = error / domain[2];
            error = error <= NEGLIGIBLE_ERROR ? 0 : error;
            error = error > MAX_ERROR ? MAX_ERROR : error;
            node.radiusScale = 1 - 0.5 * error / MAX_ERROR;
        }
        return node;
    }
    calculatePetalPath(peak, width, radiusScale, domain) {
        const path = [
            [0, 0],
            [0.5 * radiusScale, this.calculatePolarAngle(peak - width, domain)],
            [1 * radiusScale, this.calculatePolarAngle(peak, domain)],
            [0.5 * radiusScale, this.calculatePolarAngle(peak + width, domain)],
        ];
        return path;
    }
    normalize(value, domain) {
        value = value - domain[0];
        value = value % domain[2];
        if (value < 0) {
            value += domain[2];
        }
        return value;
    }
    calculatePolarCoordinate(value, domain) {
        value = this.normalize(value, domain);
        return this.normalizedPeakToPolar(value, domain[2]);
    }
    normalizedPeakToPolar(value, range) {
        return [
            Math.cos(value * 2 * Math.PI / range - Math.PI / 2),
            Math.sin(value * 2 * Math.PI / range - Math.PI / 2),
            value
        ];
    }
    calculatePolarAngle(value, domain) {
        value = this.normalize(value, domain);
        return value * 2 * Math.PI / domain[2];
    }
}

class BD2ColorPalette {
    static { this.schemeCategory10 = [
        '#1f77b4',
        '#ff7f0e',
        '#2ca02c',
        '#d62728',
        '#9467bd',
        '#8c564b',
        '#e377c2',
        '#7f7f7f',
        '#bcbd22',
        '#17becf'
    ]; }
    static { this.schemeCategory20 = [
        '#1f77b4',
        '#aec7e8',
        '#ff7f0e',
        '#ffbb78',
        '#2ca02c',
        '#98df8a',
        '#d62728',
        '#ff9896',
        '#9467bd',
        '#c5b0d5',
        '#8c564b',
        '#c49c94',
        '#e377c2',
        '#f7b6d2',
        '#7f7f7f',
        '#c7c7c7',
        '#bcbd22',
        '#dbdb8d',
        '#17becf',
        '#9edae5'
    ]; }
    static extendPalette(palette, size) {
        if (!palette || palette.length === 0) {
            palette = ['black'];
        }
        const out = [];
        for (let i = 0; i < size; i++) {
            out.push(palette[i % palette.length]);
        }
        return out;
    }
    static palette(size) {
        if (size <= BD2ColorPalette.schemeCategory10.length) {
            return BD2ColorPalette.extendPalette(BD2ColorPalette.schemeCategory10, size);
        }
        else {
            return BD2ColorPalette.extendPalette(BD2ColorPalette.schemeCategory20, size);
        }
    }
}

class GraphicContext {
}
class LookAndFeel {
    constructor() {
        this.baseTransitionsTime = 400;
        this.gridColor = '#CDCDCD';
        this.axisColor = 'white';
        this.axisWidth = '2px';
        // done by css
        // axisFontSize: "10px",
        // tooltipFontSize: "11px",
        this.dotsCircleRadius = 4;
        this.dotsCircleStrokeWidth = '1px';
        this.dotsCircleFillOpacity = 0.5;
        this.petalAreaOpacity = 0.35;
        this.petalAreaOpacityActive = 0.7;
        this.petalLineWidth = '3px';
        this.petalCircleRadius = 4;
        this.petalCircleOpacity = 0.8;
    }
}

class PolarPlotComponent {
    set domain(domain) {
        this._domain = [domain[0], domain[1], domain[1] - domain[0]];
    }
    constructor(ngZone, changeDetectorRef, element) {
        this.ngZone = ngZone;
        this.changeDetectorRef = changeDetectorRef;
        this.removed = [];
        this.scaleRadius = true;
        this.scaleWidth = false;
        this.showIndividuals = 'selected';
        this.palette = [];
        this.labels = [];
        this.labelsOn = true;
        this.lookAndFeel = new LookAndFeel();
        this.colors = new EventEmitter();
        this.showAllIndividuals = false;
        this.showSelectedIndividuals = false;
        //private individualPolarData: PolarPoint[][];
        this.graphicContext = new GraphicContext();
        this.d3 = d3;
        // this.d3 = d3Service.getD3();
        this.parentNativeElement = element.nativeElement;
        this.polarUtil = new PolarDomainUtil();
    }
    /**
     * It is detached from angular to prevent unnecessary change detection
     */
    ngAfterViewInit() {
        this.changeDetectorRef.detach();
    }
    /**
     * Explicit triggers re-drawing as need to have all the parameters set (so will not redrawn if data came frist and domain later)
     * @param changes
     */
    ngOnChanges(changes) {
        if (!this.data || !this._domain) {
            return;
        }
        // console.log("Changes", changes);
        this.showSelectedIndividuals = (this.showIndividuals === 'selected');
        this.showAllIndividuals = (this.showIndividuals === 'all');
        this.updatePlot();
    }
    ngOnInit() {
        if (this.parentNativeElement !== null) {
        }
        else {
            console.error('Missing parrent element for the component');
        }
    }
    ngOnDestroy() {
        if (this.d3Svg && this.d3Svg.empty && !this.d3Svg.empty()) {
            this.d3Svg.selectAll('*').remove();
        }
    }
    initializeSvg() {
        const pWidth = 500;
        const pHeight = 500;
        const d3ParentElement = this.d3.select(this.parentNativeElement);
        this.d3Svg = d3ParentElement.select('.polarplot').append('svg');
        this.d3Svg.attr('width', '100%')
            .attr('viewBox', '0 0 ' + pWidth + ' ' + pHeight);
        const context = new GraphicContext();
        context.mainPane = this.d3Svg.append('g')
            .attr('transform', 'translate(' + (pWidth / 2) + ',' + (pHeight / 2) + ')'); // moves 0,0 of the pain to the middle of the graphics
        context.radius = Math.min(pWidth, pHeight) / 2 - 30;
        return context;
    }
    prepareLegendtip(context) {
        if (!context.legendtip) {
            // Set up the small tooltip in the centre for when you hover over a circle
            context.legendtip = context.mainPane.append('g')
                .classed('legendtipWrapper', true);
            context.legendtipBox = context.legendtip.append('rect')
                .style('fill', 'white')
                .style('fill-opacity', 0.9)
                .style('stroke', 'grey');
            context.legendtipText = context.legendtip.append('text')
                .attr('class', 'legendtip')
                .attr('text-anchor', 'middle')
                // .attr("dy", "0.35em")
                // .style("font-size", this.lookAndFeel.tooltipFontSize) //"11px")
                .style('opacity', 1);
            context.legendtip
                // .style("visibility", "hidden");
                .style('display', 'none');
        }
        return context;
    }
    showLegendtip(p, radius) {
        if (!this.labelsOn) {
            return;
        }
        this.graphicContext.legendtipText
            .attr('x', 0)
            .attr('y', 0)
            .text(p.label);
        // it has to be before the box cause of the bug in firefox
        this.graphicContext.legendtip
            // .style("visibility", "visible");
            .style('display', null);
        const bbox = this.graphicContext.legendtipText.node().getBBox();
        this.graphicContext.legendtipBox
            .attr('x', bbox.x - 3)
            .attr('y', bbox.y - 2)
            .attr('width', bbox.width + 6)
            .attr('height', bbox.height + 4);
    }
    hideLegendtip() {
        this.graphicContext.legendtip
            // .style("visibility", "hidden");
            .style('display', 'none');
    }
    prepareTooltip(context) {
        if (!context.tooltip) {
            // Set up the small tooltip for when you hover over a circle
            context.tooltip = context.mainPane.append('g')
                .classed('tooltipWrapper', true);
            context.tooltipBox = context.tooltip.append('rect')
                .style('fill', 'white')
                .style('fill-opacity', 0.8)
                .style('stroke', 'grey');
            context.tooltipText = context.tooltip.append('text')
                .attr('class', 'tooltip')
                .attr('text-anchor', 'middle')
                .attr('dy', '0.35em')
                // .style("font-size", this.lookAndFeel.tooltipFontSize) //"11px")
                .style('opacity', 1);
            context.tooltip
                // .style("visibility", "hidden");
                .style('display', 'none');
        }
        return context;
    }
    showTooltip(p, radius) {
        this.graphicContext.tooltipText
            .attr('x', (radius + 15) * p.polarCoordinates[0])
            .attr('y', (radius + 15) * p.polarCoordinates[1])
            .text(p.roundedPeak);
        // it has to be before the get BBox cause of the firefox errors
        this.graphicContext.tooltip
            // .style("visibility", "visible");
            .style('display', null);
        const bbox = this.graphicContext.tooltipText.node().getBBox();
        this.graphicContext.tooltipBox
            .attr('x', bbox.x - 3)
            .attr('y', bbox.y - 2)
            .attr('width', bbox.width + 6)
            .attr('height', bbox.height + 4);
    }
    hideTooltip() {
        // this.graphicContext.tooltip
        // .transition().duration(this.lookAndFeel.baseTransitionsTime / 2)
        // .style("opacity", 0);
        this.graphicContext.tooltip
            // .style("visibility", "hidden");
            .style('display', 'none');
    }
    updatePlot() {
        if (!this.d3Svg) {
            this.graphicContext = this.initializeSvg();
            this.graphicContext = this.plotAxisGrid(this.graphicContext);
        }
        // the grid is plotted only once, only the lables are updated
        this.updateAxisLabels(this._domain, this.graphicContext.axisGrid);
        this.graphicContext = this.updatePalette(this.data, this.palette, this.graphicContext);
        const petalNodes = this.prepareDataModel(this.data, this._domain, this.scaleRadius, this.scaleWidth, this.errors, this.labels, this.removed, this.graphicContext.palette);
        //this.individualPolarData = this.prepareIndividualPolarData(this.data, this._domain, this.removed, this.graphicContext.palette);
        //this.individualPolarData = this.individualPolarData.filter(d => d.length !== 0);
        this.graphicContext = this.plotDataPetals(petalNodes, this.scaleRadius, this.scaleWidth, this.graphicContext);
        this.graphicContext = this.plotAllDataDots(petalNodes, this.showAllIndividuals, this.graphicContext);
        this.graphicContext = this.prepareIndividualDataInset(this.graphicContext);
        this.graphicContext = this.prepareTooltip(this.graphicContext);
        this.graphicContext = this.prepareLegendtip(this.graphicContext);
    }
    prepareDataModel(dataGroups, domain, scaleRadius, scaleWidth, errors, labels, removed, palette) {
        let petalNodes = this.polarUtil.dataToPetals(this.data, this._domain, this.scaleRadius, this.scaleWidth, this.errors);
        this.labelPetals(petalNodes, labels);
        this.colorPetals(petalNodes, palette);
        // mark hidden
        removed.forEach(ix => {
            if (petalNodes[ix]) {
                petalNodes[ix].hidden = true;
                petalNodes[ix].individuals.forEach(p => p.hidden = true);
            }
        });
        // petalNodes = petalNodes.filter(n => !n.hidden);
        // remove empty data
        petalNodes = petalNodes.filter(n => !isNaN(n.peak));
        return petalNodes;
    }
    updatePalette(data, palette, context) {
        if (!palette || palette.length === 0) {
            context.palette = BD2ColorPalette.palette(data.length);
        }
        else {
            context.palette = BD2ColorPalette.extendPalette(palette, data.length);
        }
        this.colors.next(context.palette.slice());
        return context;
    }
    labelPetals(petals, labels) {
        if (!labels) {
            labels = [];
        }
        petals.forEach((n, ix) => n.label = labels[ix] ? labels[ix] : '' + (ix + 1));
    }
    colorPetals(petals, palette) {
        petals.forEach((b, ix) => {
            b.color = palette[ix];
            b.individuals.forEach(p => p.color = b.color);
        });
    }
    plotDataPetals(petalNodes, scaleRadius, scaleWidth, context) {
        const transitionsTime = this.lookAndFeel.baseTransitionsTime;
        const d3 = this.d3;
        const radius = context.radius;
        if (!context.petalsWrapper) {
            context.petalsWrapper = context.mainPane.append('g').attr('class', 'petalsWrapper');
        }
        const petalsWrapper = context.petalsWrapper;
        const petalLine = (p) => {
            return d3.lineRadial()
                .radius(function (d) {
                return radius * d[0];
            })
                .angle(function (d) {
                return d[1];
            })
                .curve(d3.curveCardinalClosed)(p.petalPath);
        };
        const instance = this;
        // so that angular change detection is not triggered for mouseover/our events or transitions
        this.ngZone.runOutsideAngular(() => {
            const petals = petalsWrapper.selectAll('.petal')
                .data(petalNodes);
            const petalAreaOpacity = this.lookAndFeel.petalAreaOpacity;
            petals
                .select('.petalsArea')
                .transition().duration(transitionsTime)
                .attr('d', petalLine)
                .style('fill', d => d.color)
                .style('fill-opacity', this.lookAndFeel.petalAreaOpacity)
                .on('interrupt', function (d) {
                d3.select(this)
                    .attr('d', petalLine)
                    .style('fill', _ => d.color)
                    .style('fill-opacity', petalAreaOpacity);
            });
            petals
                .select('.petalsLine')
                .transition().duration(transitionsTime)
                .attr('d', petalLine)
                .style('stroke', d => d.color)
                .style('stroke-opacity', 1)
                .style('stroke-width', this.lookAndFeel.petalLineWidth)
                .on('interrupt', function (d) {
                d3.select(this)
                    .attr('d', petalLine)
                    .style('stroke', _ => d.color)
                    .style('stroke-opacity', 1);
            });
            petals
                .select('.petalsCircle')
                .transition().duration(transitionsTime)
                .attr('cx', function (d, i) {
                return radius * d.polarCoordinates[0]; // Math.cos(d * 2 * Math.PI / 24 - Math.PI / 2);
            })
                .attr('cy', function (d, i) {
                return radius * d.polarCoordinates[1]; // Math.sin(d * 2 * Math.PI / 24 - Math.PI / 2);
            })
                .style('fill', d => d.color)
                .on('interrupt', function (d) {
                d3.select(this)
                    .attr('cx', function (_, i) {
                    return radius * d.polarCoordinates[0]; // Math.cos(d * 2 * Math.PI / 24 - Math.PI / 2);
                })
                    .attr('cy', function (_, i) {
                    return radius * d.polarCoordinates[1]; // Math.sin(d * 2 * Math.PI / 24 - Math.PI / 2);
                })
                    .style('fill', _ => d.color);
            });
            const newPetals = petals
                .enter()
                .append('g')
                .attr('class', 'petal');
            const petalsArea = newPetals.append('path');
            petalsArea
                .attr('class', 'petalsArea')
                .attr('d', petalLine)
                .style('fill', d => d.color)
                .style('fill-opacity', 0)
                .on('mouseover', function (evt, d) {
                d3.select(this)
                    .transition().duration(transitionsTime)
                    .style('fill-opacity', instance.lookAndFeel.petalAreaOpacityActive);
                instance.showTooltip(d, radius);
                instance.showLegendtip(d, radius);
                /*const e = petalsArea.nodes();
                console.log("Nodes",e);
                console.log("T", this);
                console.log("S",d3.select(this));
                const ix = e.indexOf(this);
                */
                instance.showIndividualDataInset(d, radius);
            })
                .on('mouseout', function () {
                d3.select(this)
                    .transition().duration(transitionsTime)
                    .style('fill-opacity', instance.lookAndFeel.petalAreaOpacity);
                instance.hideTooltip();
                instance.hideLegendtip();
                instance.hideIndividualDataInset();
            })
                .transition().duration(transitionsTime)
                .style('fill-opacity', this.lookAndFeel.petalAreaOpacity);
            newPetals
                .append('path')
                .style('stroke-opacity', 0)
                .transition().duration(transitionsTime)
                .attr('class', 'petalsLine')
                .attr('d', petalLine)
                .style('stroke-width', this.lookAndFeel.petalLineWidth)
                .style('stroke', d => d.color)
                .style('fill', 'none')
                .style('stroke-opacity', 1);
            // .style("filter" , "url(#glow)");
            // Append the circles
            newPetals
                .append('circle')
                .attr('class', 'petalsCircle')
                .attr('cx', function (d, i) {
                return radius * d.polarCoordinates[0]; // Math.cos(d * 2 * Math.PI / 24 - Math.PI / 2);
            })
                .attr('cy', function (d, i) {
                return radius * d.polarCoordinates[1]; // Math.sin(d * 2 * Math.PI / 24 - Math.PI / 2);
            })
                .attr('r', this.lookAndFeel.petalCircleRadius)
                .style('fill', d => d.color)
                .style('fill-opacity', this.lookAndFeel.petalCircleOpacity);
            petals.exit()
                // .transition().duration(transitionsTime / 2)
                // .style('opacity', 0.0)
                .remove();
            const petalsAll = petalsWrapper.selectAll('.petal')
                // .style("visibility", (n:PetalNode) => n.hidden ? "hidden":"visible");
                .style('display', (n) => n.hidden ? 'none' : null);
        });
        return context;
    }
    /*
    prepareIndividualPolarData(dataGroups: number[][], domain: number[],
                               removed: number[], palette: string[]): PolarPoint[][] {
      // append group index to the data so the colors can be generated for each data point (ix is for the parrent so it would
      // not be available
      const ind = dataGroups.map((g, ix) => g.map(a => {
        const v = new PolarPoint(this.polarUtil.calculatePolarCoordinate(a, domain), palette[ix]);
        return v;
      }));
      removed.forEach (ix => {
        if (ind[ix]) {
          ind[ix].forEach(p => p.hidden = true);
        }
      });
      return ind;
    }*/
    prepareIndividualDataInset(context) {
        if (!context.individualDotsInsetWrapper) {
            context.individualDotsInsetWrapper = context.mainPane.append('g').attr('class', 'dotsInset');
        }
        // the actual plotting happens in showIndividuals as it is data depended
        // we always hide it with new data first;
        this.hideIndividualDataInset();
        return context;
    }
    hideIndividualDataInset() {
        if (!this.graphicContext.individualDotsInsetWrapper) {
            return;
        }
        this.graphicContext.individualDotsInsetWrapper
            .style('opacity', 0.0);
    }
    showIndividualDataInset(p, radius) {
        if (!this.graphicContext.individualDotsInsetWrapper || !p.individuals || !this.showSelectedIndividuals) {
            return;
        }
        // console.log("P: "+p.polarCoordinates[0], p.polarCoordinates);
        const transitionsTime = this.lookAndFeel.baseTransitionsTime / 2;
        const d3 = this.d3;
        // console.log("Ix",ix);
        // console.log("D",this.individualPolarData[ix]);
        const individuals = p.individuals; // this.individualPolarData[ix];
        const dots = this.graphicContext.individualDotsInsetWrapper.selectAll('.dotsCircle')
            .data(individuals);
        // existing dots
        dots
            .interrupt()
            .style('opacity', 0.2)
            .attr('cx', radius * p.polarCoordinates[0])
            .attr('cy', radius * p.polarCoordinates[1])
            .style('stroke', p.color)
            .style('fill', p.color)
            .transition().duration(transitionsTime)
            .style('opacity', 1)
            .attr('cx', d => radius * d.xy[0])
            .attr('cy', d => radius * d.xy[1]) // Math.sin(d * 2 * Math.PI / 24 - Math.PI / 2);
        ;
        // new dots
        dots.enter()
            .append('circle')
            .style('opacity', 0.2)
            .attr('class', 'dotsCircle')
            .attr('cx', radius * p.polarCoordinates[0])
            .attr('cy', radius * p.polarCoordinates[1])
            .attr('r', this.lookAndFeel.dotsCircleRadius)
            .style('stroke-width', this.lookAndFeel.dotsCircleStrokeWidth)
            .style('stroke', p.color)
            .style('fill', p.color)
            .style('fill-opacity', this.lookAndFeel.dotsCircleFillOpacity)
            .transition().duration(transitionsTime)
            .style('opacity', 1)
            .attr('cx', d => radius * d.xy[0])
            .attr('cy', d => radius * d.xy[1]) // Math.sin(d * 2 * Math.PI / 24 - Math.PI / 2);
        ;
        // exit
        dots.exit()
            .remove();
        this.graphicContext.individualDotsInsetWrapper
            .style('opacity', 1);
    }
    plotAllDataDots(petals, showDots, context) {
        const transitionsTime = this.lookAndFeel.baseTransitionsTime;
        const d3 = this.d3;
        const radius = context.radius;
        if (!context.dotsWrapper) {
            context.dotsWrapper = context.mainPane.append('g').attr('class', 'dotsWrapper');
        }
        const dotsWrapper = context.dotsWrapper;
        if (!showDots) {
            context.dotsWrapper.style('opacity', 0.0);
            return context;
        }
        else {
            context.dotsWrapper.style('opacity', 1);
        }
        const dotsData = petals.map(p => p.individuals);
        const instance = this;
        // so that angular change detection is not triggered for mouseover/our events or transitions
        this.ngZone.runOutsideAngular(() => {
            const dotsGroup = dotsWrapper.selectAll('.dotsGroup')
                .data(dotsData);
            const dotsInExisting = dotsGroup.selectAll('.dotsCircle')
                .data(d => d);
            dotsInExisting
                .transition().duration(transitionsTime)
                .attr('cx', d => radius * d.xy[0])
                .attr('cy', d => radius * d.xy[1]) // Math.sin(d * 2 * Math.PI / 24 - Math.PI / 2);
                .style('stroke', d => d.color)
                .style('fill', d => d.color);
            dotsInExisting.enter()
                .append('circle')
                .attr('class', 'dotsCircle')
                .transition().duration(transitionsTime)
                .attr('cx', d => radius * d.xy[0])
                .attr('cy', d => radius * d.xy[1]) // Math.sin(d * 2 * Math.PI / 24 - Math.PI / 2);
                .attr('r', this.lookAndFeel.dotsCircleRadius)
                .style('stroke-width', this.lookAndFeel.dotsCircleStrokeWidth)
                .style('stroke', d => d.color)
                .style('fill', d => d.color)
                .style('fill-opacity', this.lookAndFeel.dotsCircleFillOpacity);
            dotsInExisting.exit()
                .transition().duration(transitionsTime / 2)
                .style('opacity', 0.0)
                .remove();
            // dotsGroup enter section
            const dotsInNewGroups = dotsGroup.enter()
                .append('g')
                .attr('class', 'dotsGroup')
                .selectAll('.dotsCircle')
                .data(d => d);
            dotsInNewGroups.enter()
                .append('circle')
                .attr('class', 'dotsCircle')
                .transition().duration(transitionsTime)
                .attr('cx', d => radius * d.xy[0])
                .attr('cy', d => radius * d.xy[1]) // Math.sin(d * 2 * Math.PI / 24 - Math.PI / 2);
                .attr('r', this.lookAndFeel.dotsCircleRadius)
                .style('stroke-width', this.lookAndFeel.dotsCircleStrokeWidth)
                .style('stroke', d => d.color)
                .style('fill', d => d.color)
                .style('fill-opacity', this.lookAndFeel.dotsCircleFillOpacity);
            // dotsGroup exit section
            dotsGroup.exit()
                .transition().duration(transitionsTime / 2)
                .style('opacity', 0.0)
                .remove();
        });
        const dotsGroup = dotsWrapper // .selectAll(".dotsGroup")
            .selectAll('.dotsCircle')
            // .style("visibility", (n:PolarPoint) => n.hidden ? "hidden":"visible");
            .style('display', (n) => n.hidden ? 'none' : null);
        return context;
    }
    /*
    plotAllDataDots(dotsData: PolarPoint[][], showDots: boolean,
                    context: GraphicContext): GraphicContext {
  
  
      const transitionsTime = this.lookAndFeel.baseTransitionsTime;
      const d3 = this.d3;
      const radius = context.radius;
  
      if (!context.dotsWrapper) {
        context.dotsWrapper = context.mainPane.append<SVGGElement>('g').attr('class', 'dotsWrapper');
      }
      const dotsWrapper = context.dotsWrapper;
  
      if (!showDots) {
        context.dotsWrapper.style('opacity', 0.0);
        return context;
      } else {
        context.dotsWrapper.style('opacity', 1);
      }
  
      const instance = this;
  
  
      // so that angular change detection is not triggered for mouseover/our events or transitions
      this.ngZone.runOutsideAngular(() => {
  
        const dotsGroup = dotsWrapper.selectAll('.dotsGroup')
          .data(dotsData);
  
  
        const dotsInExisting = dotsGroup.selectAll('.dotsCircle')
          .data(d => d);
  
        dotsInExisting
          .transition().duration(transitionsTime)
          .attr('cx', d => radius * d.xy[0])
          .attr('cy', d => radius * d.xy[1]) // Math.sin(d * 2 * Math.PI / 24 - Math.PI / 2);
          .style('stroke', d => d.color)
          .style('fill', d => d.color)
        ;
  
        dotsInExisting.enter()
          .append('circle')
          .attr('class', 'dotsCircle')
          .transition().duration(transitionsTime)
          .attr('cx', d => radius * d.xy[0])
          .attr('cy', d => radius * d.xy[1]) // Math.sin(d * 2 * Math.PI / 24 - Math.PI / 2);
          .attr('r', this.lookAndFeel.dotsCircleRadius)
          .style('stroke-width', this.lookAndFeel.dotsCircleStrokeWidth)
          .style('stroke', d => d.color)
          .style('fill', d => d.color)
          .style('fill-opacity', this.lookAndFeel.dotsCircleFillOpacity);
  
  
        dotsInExisting.exit()
          .transition().duration(transitionsTime / 2)
          .style('opacity', 0.0)
          .remove();
  
        // dotsGroup enter section
        const dotsInNewGroups = dotsGroup.enter()
          .append<SVGGElement>('g')
          .attr('class', 'dotsGroup')
          .selectAll('.dotsCircle')
          .data(d => d);
  
  
        dotsInNewGroups.enter()
          .append('circle')
          .attr('class', 'dotsCircle')
          .transition().duration(transitionsTime)
          .attr('cx', d => radius * d.xy[0])
          .attr('cy', d => radius * d.xy[1]) // Math.sin(d * 2 * Math.PI / 24 - Math.PI / 2);
          .attr('r', this.lookAndFeel.dotsCircleRadius)
          .style('stroke-width', this.lookAndFeel.dotsCircleStrokeWidth)
          .style('stroke', d => d.color)
          .style('fill', d => d.color)
          .style('fill-opacity', this.lookAndFeel.dotsCircleFillOpacity);
  
        // dotsGroup exit section
        dotsGroup.exit()
          .transition().duration(transitionsTime / 2)
          .style('opacity', 0.0)
          .remove();
  
      });
  
      const dotsGroup = dotsWrapper// .selectAll(".dotsGroup")
        .selectAll('.dotsCircle')
        // .style("visibility", (n:PolarPoint) => n.hidden ? "hidden":"visible");
        .style('display', (n: PolarPoint) => n.hidden ? 'none' : null);
  
      return context;
    }
    */
    plotAxisGrid(context) {
        if (context.axisGrid) {
            return context; // this.axisGrid; //we only plot grid once
        }
        const radius = context.radius;
        const axisGrid = context.axisGrid = context.mainPane.append('g').attr('class', 'axisWrapper');
        axisGrid.selectAll('.levels')
            .data([10, 2, 1])
            .enter()
            .append('circle')
            .attr('class', 'gridCircle')
            .attr('r', function (d, i) {
            return radius / d;
        })
            .style('fill', this.lookAndFeel.gridColor)
            .style('stroke', this.lookAndFeel.gridColor)
            .style('fill-opacity', 0.15);
        // .style("filter" , "url(#glow)");
        const axis = axisGrid.selectAll('.axis')
            .data([0, 3, 6, 9, 12, 15, 18, 21].map(v => this.polarUtil.normalizedPeakToPolar(v, 24)
        // polar coordinates with attached original value for the label
        ))
            .enter()
            .append('g')
            .attr('class', 'axis');
        axis.append('line')
            .attr('x1', 0)
            .attr('y1', 0)
            .attr('x2', function (d, i) {
            return radius * d[0]; // Math.cos(d * 2 * Math.PI / 24 - Math.PI / 2);
        })
            .attr('y2', function (d, i) {
            return radius * d[1]; // Math.sin(d * 2 * Math.PI / 24 - Math.PI / 2);
        })
            .attr('class', 'line')
            .style('stroke', this.lookAndFeel.axisColor)
            .style('stroke-dasharray', '5 5')
            .style('stroke-width', this.lookAndFeel.axisWidth);
        axis.append('text')
            .attr('class', 'legend')
            // .style("font-size", this.lookAndFeel.axisFontSize) //"10px")
            .attr('text-anchor', 'middle')
            .attr('dy', '0.35em')
            .attr('x', function (d, i) {
            return (radius + 15) * d[0]; // Math.cos(d * 2 * Math.PI / 24 - Math.PI / 2);
        })
            .attr('y', function (d, i) {
            return (radius + 15) * d[1]; // Math.sin(d * 2 * Math.PI / 24 - Math.PI / 2);
        })
            .text(function (d, i) {
            return d[2];
        });
        return context;
    }
    updateAxisLabels(domain, axisGrid) {
        const range = domain[1] - domain[0];
        const axis = axisGrid.selectAll('.axis');
        axis.select('text')
            .text(function (d, i) {
            if (i === 0) {
                return SmartRounder.round(domain[1]) + ' / ' + SmartRounder.round(domain[0]);
            }
            else {
                return SmartRounder.round(domain[0] + d[2] / 24 * range);
            }
        });
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: PolarPlotComponent, deps: [{ token: i0.NgZone }, { token: i0.ChangeDetectorRef }, { token: i0.ElementRef }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: PolarPlotComponent, selector: "bd2-ngx-polar-plot", inputs: { data: "data", errors: "errors", removed: "removed", scaleRadius: "scaleRadius", scaleWidth: "scaleWidth", showIndividuals: "showIndividuals", domain: "domain", palette: "palette", labels: "labels", labelsOn: "labelsOn", lookAndFeel: "lookAndFeel" }, outputs: { colors: "colors" }, usesOnChanges: true, ngImport: i0, template: `
    <div class="polarplot"></div>
  `, isInline: true, styles: [":host ::ng-deep .axis .legend{font-size:15px}:host ::ng-deep .tooltip{font-size:15px}:host ::ng-deep .legendtip{font-size:18px}\n"], changeDetection: i0.ChangeDetectionStrategy.OnPush }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: PolarPlotComponent, decorators: [{
            type: Component,
            args: [{ selector: 'bd2-ngx-polar-plot', changeDetection: ChangeDetectionStrategy.OnPush, template: `
    <div class="polarplot"></div>
  `, styles: [":host ::ng-deep .axis .legend{font-size:15px}:host ::ng-deep .tooltip{font-size:15px}:host ::ng-deep .legendtip{font-size:18px}\n"] }]
        }], ctorParameters: function () { return [{ type: i0.NgZone }, { type: i0.ChangeDetectorRef }, { type: i0.ElementRef }]; }, propDecorators: { data: [{
                type: Input
            }], errors: [{
                type: Input
            }], removed: [{
                type: Input
            }], scaleRadius: [{
                type: Input
            }], scaleWidth: [{
                type: Input
            }], showIndividuals: [{
                type: Input
            }], domain: [{
                type: Input
            }], palette: [{
                type: Input
            }], labels: [{
                type: Input
            }], labelsOn: [{
                type: Input
            }], lookAndFeel: [{
                type: Input
            }], colors: [{
                type: Output
            }] } });

class BD2NgxPolarplotModule {
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: BD2NgxPolarplotModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "16.2.12", ngImport: i0, type: BD2NgxPolarplotModule, declarations: [PolarPlotComponent], exports: [PolarPlotComponent] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: BD2NgxPolarplotModule }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: BD2NgxPolarplotModule, decorators: [{
            type: NgModule,
            args: [{
                    declarations: [PolarPlotComponent],
                    imports: [
                    // CommonModule
                    ],
                    exports: [PolarPlotComponent]
                }]
        }] });

/*
 * Public API Surface of bd2-ngx-polarplot
 */

/**
 * Generated bundle index. Do not edit.
 */

export { BD2NgxPolarplotModule, PolarPlotComponent };
//# sourceMappingURL=bd2-ngx-polarplot.mjs.map
