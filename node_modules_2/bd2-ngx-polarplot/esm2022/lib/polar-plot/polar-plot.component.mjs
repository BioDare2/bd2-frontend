import { ChangeDetectionStrategy, Component, Input, Output, EventEmitter } from '@angular/core';
import * as d3 from 'd3';
import { PolarDomainUtil } from '../polar-plot-utils/polar-domain-util';
import { SmartRounder } from '../polar-plot-utils/smart-rounding';
import { BD2ColorPalette } from '../polar-plot-utils/color-palette';
import { GraphicContext, LookAndFeel } from './polar-plot.dom';
import * as i0 from "@angular/core";
export class PolarPlotComponent {
    set domain(domain) {
        this._domain = [domain[0], domain[1], domain[1] - domain[0]];
    }
    constructor(ngZone, changeDetectorRef, element) {
        this.ngZone = ngZone;
        this.changeDetectorRef = changeDetectorRef;
        this.removed = [];
        this.scaleRadius = true;
        this.scaleWidth = false;
        this.showIndividuals = 'selected';
        this.palette = [];
        this.labels = [];
        this.labelsOn = true;
        this.lookAndFeel = new LookAndFeel();
        this.colors = new EventEmitter();
        this.showAllIndividuals = false;
        this.showSelectedIndividuals = false;
        //private individualPolarData: PolarPoint[][];
        this.graphicContext = new GraphicContext();
        this.d3 = d3;
        // this.d3 = d3Service.getD3();
        this.parentNativeElement = element.nativeElement;
        this.polarUtil = new PolarDomainUtil();
    }
    /**
     * It is detached from angular to prevent unnecessary change detection
     */
    ngAfterViewInit() {
        this.changeDetectorRef.detach();
    }
    /**
     * Explicit triggers re-drawing as need to have all the parameters set (so will not redrawn if data came frist and domain later)
     * @param changes
     */
    ngOnChanges(changes) {
        if (!this.data || !this._domain) {
            return;
        }
        // console.log("Changes", changes);
        this.showSelectedIndividuals = (this.showIndividuals === 'selected');
        this.showAllIndividuals = (this.showIndividuals === 'all');
        this.updatePlot();
    }
    ngOnInit() {
        if (this.parentNativeElement !== null) {
        }
        else {
            console.error('Missing parrent element for the component');
        }
    }
    ngOnDestroy() {
        if (this.d3Svg && this.d3Svg.empty && !this.d3Svg.empty()) {
            this.d3Svg.selectAll('*').remove();
        }
    }
    initializeSvg() {
        const pWidth = 500;
        const pHeight = 500;
        const d3ParentElement = this.d3.select(this.parentNativeElement);
        this.d3Svg = d3ParentElement.select('.polarplot').append('svg');
        this.d3Svg.attr('width', '100%')
            .attr('viewBox', '0 0 ' + pWidth + ' ' + pHeight);
        const context = new GraphicContext();
        context.mainPane = this.d3Svg.append('g')
            .attr('transform', 'translate(' + (pWidth / 2) + ',' + (pHeight / 2) + ')'); // moves 0,0 of the pain to the middle of the graphics
        context.radius = Math.min(pWidth, pHeight) / 2 - 30;
        return context;
    }
    prepareLegendtip(context) {
        if (!context.legendtip) {
            // Set up the small tooltip in the centre for when you hover over a circle
            context.legendtip = context.mainPane.append('g')
                .classed('legendtipWrapper', true);
            context.legendtipBox = context.legendtip.append('rect')
                .style('fill', 'white')
                .style('fill-opacity', 0.9)
                .style('stroke', 'grey');
            context.legendtipText = context.legendtip.append('text')
                .attr('class', 'legendtip')
                .attr('text-anchor', 'middle')
                // .attr("dy", "0.35em")
                // .style("font-size", this.lookAndFeel.tooltipFontSize) //"11px")
                .style('opacity', 1);
            context.legendtip
                // .style("visibility", "hidden");
                .style('display', 'none');
        }
        return context;
    }
    showLegendtip(p, radius) {
        if (!this.labelsOn) {
            return;
        }
        this.graphicContext.legendtipText
            .attr('x', 0)
            .attr('y', 0)
            .text(p.label);
        // it has to be before the box cause of the bug in firefox
        this.graphicContext.legendtip
            // .style("visibility", "visible");
            .style('display', null);
        const bbox = this.graphicContext.legendtipText.node().getBBox();
        this.graphicContext.legendtipBox
            .attr('x', bbox.x - 3)
            .attr('y', bbox.y - 2)
            .attr('width', bbox.width + 6)
            .attr('height', bbox.height + 4);
    }
    hideLegendtip() {
        this.graphicContext.legendtip
            // .style("visibility", "hidden");
            .style('display', 'none');
    }
    prepareTooltip(context) {
        if (!context.tooltip) {
            // Set up the small tooltip for when you hover over a circle
            context.tooltip = context.mainPane.append('g')
                .classed('tooltipWrapper', true);
            context.tooltipBox = context.tooltip.append('rect')
                .style('fill', 'white')
                .style('fill-opacity', 0.8)
                .style('stroke', 'grey');
            context.tooltipText = context.tooltip.append('text')
                .attr('class', 'tooltip')
                .attr('text-anchor', 'middle')
                .attr('dy', '0.35em')
                // .style("font-size", this.lookAndFeel.tooltipFontSize) //"11px")
                .style('opacity', 1);
            context.tooltip
                // .style("visibility", "hidden");
                .style('display', 'none');
        }
        return context;
    }
    showTooltip(p, radius) {
        this.graphicContext.tooltipText
            .attr('x', (radius + 15) * p.polarCoordinates[0])
            .attr('y', (radius + 15) * p.polarCoordinates[1])
            .text(p.roundedPeak);
        // it has to be before the get BBox cause of the firefox errors
        this.graphicContext.tooltip
            // .style("visibility", "visible");
            .style('display', null);
        const bbox = this.graphicContext.tooltipText.node().getBBox();
        this.graphicContext.tooltipBox
            .attr('x', bbox.x - 3)
            .attr('y', bbox.y - 2)
            .attr('width', bbox.width + 6)
            .attr('height', bbox.height + 4);
    }
    hideTooltip() {
        // this.graphicContext.tooltip
        // .transition().duration(this.lookAndFeel.baseTransitionsTime / 2)
        // .style("opacity", 0);
        this.graphicContext.tooltip
            // .style("visibility", "hidden");
            .style('display', 'none');
    }
    updatePlot() {
        if (!this.d3Svg) {
            this.graphicContext = this.initializeSvg();
            this.graphicContext = this.plotAxisGrid(this.graphicContext);
        }
        // the grid is plotted only once, only the lables are updated
        this.updateAxisLabels(this._domain, this.graphicContext.axisGrid);
        this.graphicContext = this.updatePalette(this.data, this.palette, this.graphicContext);
        const petalNodes = this.prepareDataModel(this.data, this._domain, this.scaleRadius, this.scaleWidth, this.errors, this.labels, this.removed, this.graphicContext.palette);
        //this.individualPolarData = this.prepareIndividualPolarData(this.data, this._domain, this.removed, this.graphicContext.palette);
        //this.individualPolarData = this.individualPolarData.filter(d => d.length !== 0);
        this.graphicContext = this.plotDataPetals(petalNodes, this.scaleRadius, this.scaleWidth, this.graphicContext);
        this.graphicContext = this.plotAllDataDots(petalNodes, this.showAllIndividuals, this.graphicContext);
        this.graphicContext = this.prepareIndividualDataInset(this.graphicContext);
        this.graphicContext = this.prepareTooltip(this.graphicContext);
        this.graphicContext = this.prepareLegendtip(this.graphicContext);
    }
    prepareDataModel(dataGroups, domain, scaleRadius, scaleWidth, errors, labels, removed, palette) {
        let petalNodes = this.polarUtil.dataToPetals(this.data, this._domain, this.scaleRadius, this.scaleWidth, this.errors);
        this.labelPetals(petalNodes, labels);
        this.colorPetals(petalNodes, palette);
        // mark hidden
        removed.forEach(ix => {
            if (petalNodes[ix]) {
                petalNodes[ix].hidden = true;
                petalNodes[ix].individuals.forEach(p => p.hidden = true);
            }
        });
        // petalNodes = petalNodes.filter(n => !n.hidden);
        // remove empty data
        petalNodes = petalNodes.filter(n => !isNaN(n.peak));
        return petalNodes;
    }
    updatePalette(data, palette, context) {
        if (!palette || palette.length === 0) {
            context.palette = BD2ColorPalette.palette(data.length);
        }
        else {
            context.palette = BD2ColorPalette.extendPalette(palette, data.length);
        }
        this.colors.next(context.palette.slice());
        return context;
    }
    labelPetals(petals, labels) {
        if (!labels) {
            labels = [];
        }
        petals.forEach((n, ix) => n.label = labels[ix] ? labels[ix] : '' + (ix + 1));
    }
    colorPetals(petals, palette) {
        petals.forEach((b, ix) => {
            b.color = palette[ix];
            b.individuals.forEach(p => p.color = b.color);
        });
    }
    plotDataPetals(petalNodes, scaleRadius, scaleWidth, context) {
        const transitionsTime = this.lookAndFeel.baseTransitionsTime;
        const d3 = this.d3;
        const radius = context.radius;
        if (!context.petalsWrapper) {
            context.petalsWrapper = context.mainPane.append('g').attr('class', 'petalsWrapper');
        }
        const petalsWrapper = context.petalsWrapper;
        const petalLine = (p) => {
            return d3.lineRadial()
                .radius(function (d) {
                return radius * d[0];
            })
                .angle(function (d) {
                return d[1];
            })
                .curve(d3.curveCardinalClosed)(p.petalPath);
        };
        const instance = this;
        // so that angular change detection is not triggered for mouseover/our events or transitions
        this.ngZone.runOutsideAngular(() => {
            const petals = petalsWrapper.selectAll('.petal')
                .data(petalNodes);
            const petalAreaOpacity = this.lookAndFeel.petalAreaOpacity;
            petals
                .select('.petalsArea')
                .transition().duration(transitionsTime)
                .attr('d', petalLine)
                .style('fill', d => d.color)
                .style('fill-opacity', this.lookAndFeel.petalAreaOpacity)
                .on('interrupt', function (d) {
                d3.select(this)
                    .attr('d', petalLine)
                    .style('fill', _ => d.color)
                    .style('fill-opacity', petalAreaOpacity);
            });
            petals
                .select('.petalsLine')
                .transition().duration(transitionsTime)
                .attr('d', petalLine)
                .style('stroke', d => d.color)
                .style('stroke-opacity', 1)
                .style('stroke-width', this.lookAndFeel.petalLineWidth)
                .on('interrupt', function (d) {
                d3.select(this)
                    .attr('d', petalLine)
                    .style('stroke', _ => d.color)
                    .style('stroke-opacity', 1);
            });
            petals
                .select('.petalsCircle')
                .transition().duration(transitionsTime)
                .attr('cx', function (d, i) {
                return radius * d.polarCoordinates[0]; // Math.cos(d * 2 * Math.PI / 24 - Math.PI / 2);
            })
                .attr('cy', function (d, i) {
                return radius * d.polarCoordinates[1]; // Math.sin(d * 2 * Math.PI / 24 - Math.PI / 2);
            })
                .style('fill', d => d.color)
                .on('interrupt', function (d) {
                d3.select(this)
                    .attr('cx', function (_, i) {
                    return radius * d.polarCoordinates[0]; // Math.cos(d * 2 * Math.PI / 24 - Math.PI / 2);
                })
                    .attr('cy', function (_, i) {
                    return radius * d.polarCoordinates[1]; // Math.sin(d * 2 * Math.PI / 24 - Math.PI / 2);
                })
                    .style('fill', _ => d.color);
            });
            const newPetals = petals
                .enter()
                .append('g')
                .attr('class', 'petal');
            const petalsArea = newPetals.append('path');
            petalsArea
                .attr('class', 'petalsArea')
                .attr('d', petalLine)
                .style('fill', d => d.color)
                .style('fill-opacity', 0)
                .on('mouseover', function (evt, d) {
                d3.select(this)
                    .transition().duration(transitionsTime)
                    .style('fill-opacity', instance.lookAndFeel.petalAreaOpacityActive);
                instance.showTooltip(d, radius);
                instance.showLegendtip(d, radius);
                /*const e = petalsArea.nodes();
                console.log("Nodes",e);
                console.log("T", this);
                console.log("S",d3.select(this));
                const ix = e.indexOf(this);
                */
                instance.showIndividualDataInset(d, radius);
            })
                .on('mouseout', function () {
                d3.select(this)
                    .transition().duration(transitionsTime)
                    .style('fill-opacity', instance.lookAndFeel.petalAreaOpacity);
                instance.hideTooltip();
                instance.hideLegendtip();
                instance.hideIndividualDataInset();
            })
                .transition().duration(transitionsTime)
                .style('fill-opacity', this.lookAndFeel.petalAreaOpacity);
            newPetals
                .append('path')
                .style('stroke-opacity', 0)
                .transition().duration(transitionsTime)
                .attr('class', 'petalsLine')
                .attr('d', petalLine)
                .style('stroke-width', this.lookAndFeel.petalLineWidth)
                .style('stroke', d => d.color)
                .style('fill', 'none')
                .style('stroke-opacity', 1);
            // .style("filter" , "url(#glow)");
            // Append the circles
            newPetals
                .append('circle')
                .attr('class', 'petalsCircle')
                .attr('cx', function (d, i) {
                return radius * d.polarCoordinates[0]; // Math.cos(d * 2 * Math.PI / 24 - Math.PI / 2);
            })
                .attr('cy', function (d, i) {
                return radius * d.polarCoordinates[1]; // Math.sin(d * 2 * Math.PI / 24 - Math.PI / 2);
            })
                .attr('r', this.lookAndFeel.petalCircleRadius)
                .style('fill', d => d.color)
                .style('fill-opacity', this.lookAndFeel.petalCircleOpacity);
            petals.exit()
                // .transition().duration(transitionsTime / 2)
                // .style('opacity', 0.0)
                .remove();
            const petalsAll = petalsWrapper.selectAll('.petal')
                // .style("visibility", (n:PetalNode) => n.hidden ? "hidden":"visible");
                .style('display', (n) => n.hidden ? 'none' : null);
        });
        return context;
    }
    /*
    prepareIndividualPolarData(dataGroups: number[][], domain: number[],
                               removed: number[], palette: string[]): PolarPoint[][] {
      // append group index to the data so the colors can be generated for each data point (ix is for the parrent so it would
      // not be available
      const ind = dataGroups.map((g, ix) => g.map(a => {
        const v = new PolarPoint(this.polarUtil.calculatePolarCoordinate(a, domain), palette[ix]);
        return v;
      }));
      removed.forEach (ix => {
        if (ind[ix]) {
          ind[ix].forEach(p => p.hidden = true);
        }
      });
      return ind;
    }*/
    prepareIndividualDataInset(context) {
        if (!context.individualDotsInsetWrapper) {
            context.individualDotsInsetWrapper = context.mainPane.append('g').attr('class', 'dotsInset');
        }
        // the actual plotting happens in showIndividuals as it is data depended
        // we always hide it with new data first;
        this.hideIndividualDataInset();
        return context;
    }
    hideIndividualDataInset() {
        if (!this.graphicContext.individualDotsInsetWrapper) {
            return;
        }
        this.graphicContext.individualDotsInsetWrapper
            .style('opacity', 0.0);
    }
    showIndividualDataInset(p, radius) {
        if (!this.graphicContext.individualDotsInsetWrapper || !p.individuals || !this.showSelectedIndividuals) {
            return;
        }
        // console.log("P: "+p.polarCoordinates[0], p.polarCoordinates);
        const transitionsTime = this.lookAndFeel.baseTransitionsTime / 2;
        const d3 = this.d3;
        // console.log("Ix",ix);
        // console.log("D",this.individualPolarData[ix]);
        const individuals = p.individuals; // this.individualPolarData[ix];
        const dots = this.graphicContext.individualDotsInsetWrapper.selectAll('.dotsCircle')
            .data(individuals);
        // existing dots
        dots
            .interrupt()
            .style('opacity', 0.2)
            .attr('cx', radius * p.polarCoordinates[0])
            .attr('cy', radius * p.polarCoordinates[1])
            .style('stroke', p.color)
            .style('fill', p.color)
            .transition().duration(transitionsTime)
            .style('opacity', 1)
            .attr('cx', d => radius * d.xy[0])
            .attr('cy', d => radius * d.xy[1]) // Math.sin(d * 2 * Math.PI / 24 - Math.PI / 2);
        ;
        // new dots
        dots.enter()
            .append('circle')
            .style('opacity', 0.2)
            .attr('class', 'dotsCircle')
            .attr('cx', radius * p.polarCoordinates[0])
            .attr('cy', radius * p.polarCoordinates[1])
            .attr('r', this.lookAndFeel.dotsCircleRadius)
            .style('stroke-width', this.lookAndFeel.dotsCircleStrokeWidth)
            .style('stroke', p.color)
            .style('fill', p.color)
            .style('fill-opacity', this.lookAndFeel.dotsCircleFillOpacity)
            .transition().duration(transitionsTime)
            .style('opacity', 1)
            .attr('cx', d => radius * d.xy[0])
            .attr('cy', d => radius * d.xy[1]) // Math.sin(d * 2 * Math.PI / 24 - Math.PI / 2);
        ;
        // exit
        dots.exit()
            .remove();
        this.graphicContext.individualDotsInsetWrapper
            .style('opacity', 1);
    }
    plotAllDataDots(petals, showDots, context) {
        const transitionsTime = this.lookAndFeel.baseTransitionsTime;
        const d3 = this.d3;
        const radius = context.radius;
        if (!context.dotsWrapper) {
            context.dotsWrapper = context.mainPane.append('g').attr('class', 'dotsWrapper');
        }
        const dotsWrapper = context.dotsWrapper;
        if (!showDots) {
            context.dotsWrapper.style('opacity', 0.0);
            return context;
        }
        else {
            context.dotsWrapper.style('opacity', 1);
        }
        const dotsData = petals.map(p => p.individuals);
        const instance = this;
        // so that angular change detection is not triggered for mouseover/our events or transitions
        this.ngZone.runOutsideAngular(() => {
            const dotsGroup = dotsWrapper.selectAll('.dotsGroup')
                .data(dotsData);
            const dotsInExisting = dotsGroup.selectAll('.dotsCircle')
                .data(d => d);
            dotsInExisting
                .transition().duration(transitionsTime)
                .attr('cx', d => radius * d.xy[0])
                .attr('cy', d => radius * d.xy[1]) // Math.sin(d * 2 * Math.PI / 24 - Math.PI / 2);
                .style('stroke', d => d.color)
                .style('fill', d => d.color);
            dotsInExisting.enter()
                .append('circle')
                .attr('class', 'dotsCircle')
                .transition().duration(transitionsTime)
                .attr('cx', d => radius * d.xy[0])
                .attr('cy', d => radius * d.xy[1]) // Math.sin(d * 2 * Math.PI / 24 - Math.PI / 2);
                .attr('r', this.lookAndFeel.dotsCircleRadius)
                .style('stroke-width', this.lookAndFeel.dotsCircleStrokeWidth)
                .style('stroke', d => d.color)
                .style('fill', d => d.color)
                .style('fill-opacity', this.lookAndFeel.dotsCircleFillOpacity);
            dotsInExisting.exit()
                .transition().duration(transitionsTime / 2)
                .style('opacity', 0.0)
                .remove();
            // dotsGroup enter section
            const dotsInNewGroups = dotsGroup.enter()
                .append('g')
                .attr('class', 'dotsGroup')
                .selectAll('.dotsCircle')
                .data(d => d);
            dotsInNewGroups.enter()
                .append('circle')
                .attr('class', 'dotsCircle')
                .transition().duration(transitionsTime)
                .attr('cx', d => radius * d.xy[0])
                .attr('cy', d => radius * d.xy[1]) // Math.sin(d * 2 * Math.PI / 24 - Math.PI / 2);
                .attr('r', this.lookAndFeel.dotsCircleRadius)
                .style('stroke-width', this.lookAndFeel.dotsCircleStrokeWidth)
                .style('stroke', d => d.color)
                .style('fill', d => d.color)
                .style('fill-opacity', this.lookAndFeel.dotsCircleFillOpacity);
            // dotsGroup exit section
            dotsGroup.exit()
                .transition().duration(transitionsTime / 2)
                .style('opacity', 0.0)
                .remove();
        });
        const dotsGroup = dotsWrapper // .selectAll(".dotsGroup")
            .selectAll('.dotsCircle')
            // .style("visibility", (n:PolarPoint) => n.hidden ? "hidden":"visible");
            .style('display', (n) => n.hidden ? 'none' : null);
        return context;
    }
    /*
    plotAllDataDots(dotsData: PolarPoint[][], showDots: boolean,
                    context: GraphicContext): GraphicContext {
  
  
      const transitionsTime = this.lookAndFeel.baseTransitionsTime;
      const d3 = this.d3;
      const radius = context.radius;
  
      if (!context.dotsWrapper) {
        context.dotsWrapper = context.mainPane.append<SVGGElement>('g').attr('class', 'dotsWrapper');
      }
      const dotsWrapper = context.dotsWrapper;
  
      if (!showDots) {
        context.dotsWrapper.style('opacity', 0.0);
        return context;
      } else {
        context.dotsWrapper.style('opacity', 1);
      }
  
      const instance = this;
  
  
      // so that angular change detection is not triggered for mouseover/our events or transitions
      this.ngZone.runOutsideAngular(() => {
  
        const dotsGroup = dotsWrapper.selectAll('.dotsGroup')
          .data(dotsData);
  
  
        const dotsInExisting = dotsGroup.selectAll('.dotsCircle')
          .data(d => d);
  
        dotsInExisting
          .transition().duration(transitionsTime)
          .attr('cx', d => radius * d.xy[0])
          .attr('cy', d => radius * d.xy[1]) // Math.sin(d * 2 * Math.PI / 24 - Math.PI / 2);
          .style('stroke', d => d.color)
          .style('fill', d => d.color)
        ;
  
        dotsInExisting.enter()
          .append('circle')
          .attr('class', 'dotsCircle')
          .transition().duration(transitionsTime)
          .attr('cx', d => radius * d.xy[0])
          .attr('cy', d => radius * d.xy[1]) // Math.sin(d * 2 * Math.PI / 24 - Math.PI / 2);
          .attr('r', this.lookAndFeel.dotsCircleRadius)
          .style('stroke-width', this.lookAndFeel.dotsCircleStrokeWidth)
          .style('stroke', d => d.color)
          .style('fill', d => d.color)
          .style('fill-opacity', this.lookAndFeel.dotsCircleFillOpacity);
  
  
        dotsInExisting.exit()
          .transition().duration(transitionsTime / 2)
          .style('opacity', 0.0)
          .remove();
  
        // dotsGroup enter section
        const dotsInNewGroups = dotsGroup.enter()
          .append<SVGGElement>('g')
          .attr('class', 'dotsGroup')
          .selectAll('.dotsCircle')
          .data(d => d);
  
  
        dotsInNewGroups.enter()
          .append('circle')
          .attr('class', 'dotsCircle')
          .transition().duration(transitionsTime)
          .attr('cx', d => radius * d.xy[0])
          .attr('cy', d => radius * d.xy[1]) // Math.sin(d * 2 * Math.PI / 24 - Math.PI / 2);
          .attr('r', this.lookAndFeel.dotsCircleRadius)
          .style('stroke-width', this.lookAndFeel.dotsCircleStrokeWidth)
          .style('stroke', d => d.color)
          .style('fill', d => d.color)
          .style('fill-opacity', this.lookAndFeel.dotsCircleFillOpacity);
  
        // dotsGroup exit section
        dotsGroup.exit()
          .transition().duration(transitionsTime / 2)
          .style('opacity', 0.0)
          .remove();
  
      });
  
      const dotsGroup = dotsWrapper// .selectAll(".dotsGroup")
        .selectAll('.dotsCircle')
        // .style("visibility", (n:PolarPoint) => n.hidden ? "hidden":"visible");
        .style('display', (n: PolarPoint) => n.hidden ? 'none' : null);
  
      return context;
    }
    */
    plotAxisGrid(context) {
        if (context.axisGrid) {
            return context; // this.axisGrid; //we only plot grid once
        }
        const radius = context.radius;
        const axisGrid = context.axisGrid = context.mainPane.append('g').attr('class', 'axisWrapper');
        axisGrid.selectAll('.levels')
            .data([10, 2, 1])
            .enter()
            .append('circle')
            .attr('class', 'gridCircle')
            .attr('r', function (d, i) {
            return radius / d;
        })
            .style('fill', this.lookAndFeel.gridColor)
            .style('stroke', this.lookAndFeel.gridColor)
            .style('fill-opacity', 0.15);
        // .style("filter" , "url(#glow)");
        const axis = axisGrid.selectAll('.axis')
            .data([0, 3, 6, 9, 12, 15, 18, 21].map(v => this.polarUtil.normalizedPeakToPolar(v, 24)
        // polar coordinates with attached original value for the label
        ))
            .enter()
            .append('g')
            .attr('class', 'axis');
        axis.append('line')
            .attr('x1', 0)
            .attr('y1', 0)
            .attr('x2', function (d, i) {
            return radius * d[0]; // Math.cos(d * 2 * Math.PI / 24 - Math.PI / 2);
        })
            .attr('y2', function (d, i) {
            return radius * d[1]; // Math.sin(d * 2 * Math.PI / 24 - Math.PI / 2);
        })
            .attr('class', 'line')
            .style('stroke', this.lookAndFeel.axisColor)
            .style('stroke-dasharray', '5 5')
            .style('stroke-width', this.lookAndFeel.axisWidth);
        axis.append('text')
            .attr('class', 'legend')
            // .style("font-size", this.lookAndFeel.axisFontSize) //"10px")
            .attr('text-anchor', 'middle')
            .attr('dy', '0.35em')
            .attr('x', function (d, i) {
            return (radius + 15) * d[0]; // Math.cos(d * 2 * Math.PI / 24 - Math.PI / 2);
        })
            .attr('y', function (d, i) {
            return (radius + 15) * d[1]; // Math.sin(d * 2 * Math.PI / 24 - Math.PI / 2);
        })
            .text(function (d, i) {
            return d[2];
        });
        return context;
    }
    updateAxisLabels(domain, axisGrid) {
        const range = domain[1] - domain[0];
        const axis = axisGrid.selectAll('.axis');
        axis.select('text')
            .text(function (d, i) {
            if (i === 0) {
                return SmartRounder.round(domain[1]) + ' / ' + SmartRounder.round(domain[0]);
            }
            else {
                return SmartRounder.round(domain[0] + d[2] / 24 * range);
            }
        });
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: PolarPlotComponent, deps: [{ token: i0.NgZone }, { token: i0.ChangeDetectorRef }, { token: i0.ElementRef }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: PolarPlotComponent, selector: "bd2-ngx-polar-plot", inputs: { data: "data", errors: "errors", removed: "removed", scaleRadius: "scaleRadius", scaleWidth: "scaleWidth", showIndividuals: "showIndividuals", domain: "domain", palette: "palette", labels: "labels", labelsOn: "labelsOn", lookAndFeel: "lookAndFeel" }, outputs: { colors: "colors" }, usesOnChanges: true, ngImport: i0, template: `
    <div class="polarplot"></div>
  `, isInline: true, styles: [":host ::ng-deep .axis .legend{font-size:15px}:host ::ng-deep .tooltip{font-size:15px}:host ::ng-deep .legendtip{font-size:18px}\n"], changeDetection: i0.ChangeDetectionStrategy.OnPush }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: PolarPlotComponent, decorators: [{
            type: Component,
            args: [{ selector: 'bd2-ngx-polar-plot', changeDetection: ChangeDetectionStrategy.OnPush, template: `
    <div class="polarplot"></div>
  `, styles: [":host ::ng-deep .axis .legend{font-size:15px}:host ::ng-deep .tooltip{font-size:15px}:host ::ng-deep .legendtip{font-size:18px}\n"] }]
        }], ctorParameters: function () { return [{ type: i0.NgZone }, { type: i0.ChangeDetectorRef }, { type: i0.ElementRef }]; }, propDecorators: { data: [{
                type: Input
            }], errors: [{
                type: Input
            }], removed: [{
                type: Input
            }], scaleRadius: [{
                type: Input
            }], scaleWidth: [{
                type: Input
            }], showIndividuals: [{
                type: Input
            }], domain: [{
                type: Input
            }], palette: [{
                type: Input
            }], labels: [{
                type: Input
            }], labelsOn: [{
                type: Input
            }], lookAndFeel: [{
                type: Input
            }], colors: [{
                type: Output
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicG9sYXItcGxvdC5jb21wb25lbnQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi9wcm9qZWN0cy9iZDItbmd4LXBvbGFycGxvdC9zcmMvbGliL3BvbGFyLXBsb3QvcG9sYXItcGxvdC5jb21wb25lbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUdMLHVCQUF1QixFQUN2QixTQUFTLEVBRVQsS0FBSyxFQUNMLE1BQU0sRUFDTixZQUFZLEVBTWIsTUFBTSxlQUFlLENBQUM7QUFHdkIsT0FBTyxLQUFLLEVBQUUsTUFBTSxJQUFJLENBQUM7QUFDekIsT0FBTyxFQUFDLGVBQWUsRUFBQyxNQUFNLHVDQUF1QyxDQUFDO0FBQ3RFLE9BQU8sRUFBQyxZQUFZLEVBQUMsTUFBTSxvQ0FBb0MsQ0FBQztBQUVoRSxPQUFPLEVBQUMsZUFBZSxFQUFDLE1BQU0sbUNBQW1DLENBQUM7QUFDbEUsT0FBTyxFQUFDLGNBQWMsRUFBRSxXQUFXLEVBQXlCLE1BQU0sa0JBQWtCLENBQUM7O0FBNEJyRixNQUFNLE9BQU8sa0JBQWtCO0lBc0I3QixJQUNJLE1BQU0sQ0FBQyxNQUF3QjtRQUNqQyxJQUFJLENBQUMsT0FBTyxHQUFHLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxFQUFFLE1BQU0sQ0FBQyxDQUFDLENBQUMsRUFBRSxNQUFNLENBQUMsQ0FBQyxDQUFDLEdBQUcsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDL0QsQ0FBQztJQWlDRCxZQUFvQixNQUFjLEVBQVUsaUJBQW9DLEVBQUUsT0FBbUI7UUFBakYsV0FBTSxHQUFOLE1BQU0sQ0FBUTtRQUFVLHNCQUFpQixHQUFqQixpQkFBaUIsQ0FBbUI7UUEvQ2hGLFlBQU8sR0FBYSxFQUFFLENBQUM7UUFHdkIsZ0JBQVcsR0FBRyxJQUFJLENBQUM7UUFHbkIsZUFBVSxHQUFHLEtBQUssQ0FBQztRQUduQixvQkFBZSxHQUEyQixVQUFVLENBQUM7UUFRckQsWUFB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QkFEZCxLQUFLO2dCQUlGLE1BQU07c0JBRFQsS0FBSztnQkFNTixPQUFPO3NCQUROLEtBQUs7Z0JBSU4sTUFBTTtzQkFETCxLQUFLO2dCQUlOLFFBQVE7c0JBRFAsS0FBSztnQkFLTixXQUFXO3NCQURWLEtBQUs7Z0JBSU4sTUFBTTtzQkFETCxNQUFNIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcclxuICBBZnRlclZpZXdJbml0LFxyXG4gIENoYW5nZURldGVjdG9yUmVmLFxyXG4gIENoYW5nZURldGVjdGlvblN0cmF0ZWd5LFxyXG4gIENvbXBvbmVudCxcclxuICBFbGVtZW50UmVmLFxyXG4gIElucHV0LFxyXG4gIE91dHB1dCxcclxuICBFdmVudEVtaXR0ZXIsXHJcbiAgTmdab25lLFxyXG4gIE9uQ2hhbmdlcyxcclxuICBPbkRlc3Ryb3ksXHJcbiAgT25Jbml0LFxyXG4gIFNpbXBsZUNoYW5nZXNcclxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuXHJcbmltcG9ydCB7U2VsZWN0aW9ufSBmcm9tICdkMyc7XHJcbmltcG9ydCAqIGFzIGQzIGZyb20gJ2QzJztcclxuaW1wb3J0IHtQb2xhckRvbWFpblV0aWx9IGZyb20gJy4uL3BvbGFyLXBsb3QtdXRpbHMvcG9sYXItZG9tYWluLXV0aWwnO1xyXG5pbXBvcnQge1NtYXJ0Um91bmRlcn0gZnJvbSAnLi4vcG9sYXItcGxvdC11dGlscy9zbWFydC1yb3VuZGluZyc7XHJcbmltcG9ydCB7UGV0YWxOb2RlLCBQb2xhclBvaW50fSBmcm9tICcuLi9wb2xhci1wbG90LXV0aWxzL3BvbGFyLXBsb3QuZG9tJztcclxuaW1wb3J0IHtCRDJDb2xvclBhbGV0dGV9IGZyb20gJy4uL3BvbGFyLXBsb3QtdXRpbHMvY29sb3ItcGFsZXR0ZSc7XHJcbmltcG9ydCB7R3JhcGhpY0NvbnRleHQsIExvb2tBbmRGZWVsLCBTaG93SW5kaXZpZHVhbHNPcHRpb25zfSBmcm9tICcuL3BvbGFyLXBsb3QuZG9tJztcclxuXHJcblxyXG5cclxuXHJcblxyXG5AQ29tcG9uZW50KHtcclxuICBzZWxlY3RvcjogJ2JkMi1uZ3gtcG9sYXItcGxvdCcsXHJcbiAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXHJcbiAgdGVtcGxhdGU6IGBcclxuICAgIDxkaXYgY2xhc3M9XCJwb2xhcnBsb3RcIj48L2Rpdj5cclxuICBgLFxyXG4gIHN0eWxlczogW1xyXG4gICAgYFxyXG4gICAgICA6aG9zdCA6Om5nLWRlZXAgLmF4aXMgLmxlZ2VuZCB7XHJcbiAgICAgICAgZm9udC1zaXplOiAxNXB4O1xyXG4gICAgICB9XHJcblxyXG4gICAgICA6aG9zdCA6Om5nLWRlZXAgLnRvb2x0aXAge1xyXG4gICAgICAgIGZvbnQtc2l6ZTogMTVweDtcclxuICAgICAgfVxyXG5cclxuICAgICAgOmhvc3QgOjpuZy1kZWVwIC5sZWdlbmR0aXAge1xyXG4gICAgICAgIGZvbnQtc2l6ZTogMThweDtcclxuICAgICAgfVxyXG4gICAgYFxyXG4gIF1cclxufSlcclxuZXhwb3J0IGNsYXNzIFBvbGFyUGxvdENvbXBvbmVudCBpbXBsZW1lbnRzIE9uSW5pdCwgQWZ0ZXJWaWV3SW5pdCwgT25DaGFuZ2VzLCBPbkRlc3Ryb3kge1xyXG5cclxuXHJcbiAgQElucHV0KClcclxuICBkYXRhOiBudW1iZXJbXVtdO1xyXG5cclxuXHJcbiAgQElucHV0KClcclxuICBlcnJvcnM6IG51bWJlcltdO1xyXG5cclxuICBASW5wdXQoKVxyXG4gIHJlbW92ZWQ6IG51bWJlcltdID0gW107XHJcblxyXG4gIEBJbnB1dCgpXHJcbiAgc2NhbGVSYWRpdXMgPSB0cnVlO1xyXG5cclxuICBASW5wdXQoKVxyXG4gIHNjYWxlV2lkdGggPSBmYWxzZTtcclxuXHJcbiAgQElucHV0KClcclxuICBzaG93SW5kaXZpZHVhbHM6IFNob3dJbmRpdmlkdWFsc09wdGlvbnMgPSAnc2VsZWN0ZWQnO1xyXG5cclxuICBASW5wdXQoKVxyXG4gIHNldCBkb21haW4oZG9tYWluOiBbbnVtYmVyLCBudW1iZXJdKSB7XHJcbiAgICB0aGlzLl9kb21haW4gPSBbZG9tYWluWzBdLCBkb21haW5bMV0sIGRvbWFpblsxXSAtIGRvbWFpblswXV07XHJcbiAgfVxyXG5cclxuICBASW5wdXQoKVxyXG4gIHBhbGV0dGU6IHN0cmluZ1tdID0gW107XHJcblxyXG4gIEBJbnB1dCgpXHJcbiAgbGFiZWxzOiBzdHJpbmdbXSA9IFtdO1xyXG5cclxuICBASW5wdXQoKVxyXG4gIGxhYmVsc09uID0gdHJ1ZTtcclxuXHJcblxyXG4gIEBJbnB1dCgpXHJcbiAgbG9va0FuZEZlZWwgPSBuZXcgTG9va0FuZEZlZWwoKTtcclxuXHJcbiAgQE91dHB1dCgpXHJcbiAgY29sb3JzID0gbmV3IEV2ZW50RW1pdHRlcjxzdHJpbmdbXT4oKTtcclxuXHJcbiAgcHJpdmF0ZSBkMztcclxuICBwcml2YXRlIHBhcmVudE5hdGl2ZUVsZW1lbnQ6IGFueTtcclxuICBwcml2YXRlIHBvbGFyVXRpbDogUG9sYXJEb21haW5VdGlsO1xyXG4gIHByaXZhdGUgZDNTdmc6IFNlbGVjdGlvbjxTVkdTVkdFbGVtZW50LCBhbnksIG51bGwsIHVuZGVmaW5lZD47XHJcblxyXG5cclxuICBwcml2YXRlIF9kb21haW46IG51bWJlcltdO1xyXG4gIHByaXZhdGUgc2hvd0FsbEluZGl2aWR1YWxzID0gZmFsc2U7XHJcbiAgcHJpdmF0ZSBzaG93U2VsZWN0ZWRJbmRpdmlkdWFscyA9IGZhbHNlO1xyXG5cclxuICAvL3ByaXZhdGUgaW5kaXZpZHVhbFBvbGFyRGF0YTogUG9sYXJQb2ludFtdW107XHJcblxyXG4gIHByaXZhdGUgZ3JhcGhpY0NvbnRleHQgPSBuZXcgR3JhcGhpY0NvbnRleHQoKTtcclxuXHJcblxyXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgbmdab25lOiBOZ1pvbmUsIHByaXZhdGUgY2hhbmdlRGV0ZWN0b3JSZWY6IENoYW5nZURldGVjdG9yUmVmLCBlbGVtZW50OiBFbGVtZW50UmVmKSB7XHJcbiAgICB0aGlzLmQzID0gZDM7XHJcbiAgICAvLyB0aGlzLmQzID0gZDNTZXJ2aWNlLmdldEQzKCk7XHJcbiAgICB0aGlzLnBhcmVudE5hdGl2ZUVsZW1lbnQgPSBlbGVtZW50Lm5hdGl2ZUVsZW1lbnQ7XHJcbiAgICB0aGlzLnBvbGFyVXRpbCA9IG5ldyBQb2xhckRvbWFpblV0aWwoKTtcclxuXHJcbiAgfVxyXG5cclxuXHJcbiAgLyoqXHJcbiAgICogSXQgaXMgZGV0YWNoZWQgZnJvbSBhbmd1bGFyIHRvIHByZXZlbnQgdW5uZWNlc3NhcnkgY2hhbmdlIGRldGVjdGlvblxyXG4gICAqL1xyXG4gIG5nQWZ0ZXJWaWV3SW5pdCgpIHtcclxuICAgIHRoaXMuY2hhbmdlRGV0ZWN0b3JSZWYuZGV0YWNoKCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBFeHBsaWNpdCB0cmlnZ2VycyByZS1kcmF3aW5nIGFzIG5lZWQgdG8gaGF2ZSBhbGwgdGhlIHBhcmFtZXRlcnMgc2V0IChzbyB3aWxsIG5vdCByZWRyYXduIGlmIGRhdGEgY2FtZSBmcmlzdCBhbmQgZG9tYWluIGxhdGVyKVxyXG4gICAqIEBwYXJhbSBjaGFuZ2VzXHJcbiAgICovXHJcbiAgbmdPbkNoYW5nZXMoY2hhbmdlczogU2ltcGxlQ2hhbmdlcykge1xyXG5cclxuICAgIGlmICghdGhpcy5kYXRhIHx8ICF0aGlzLl9kb21haW4pIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGNvbnNvbGUubG9nKFwiQ2hhbmdlc1wiLCBjaGFuZ2VzKTtcclxuXHJcbiAgICB0aGlzLnNob3dTZWxlY3RlZEluZGl2aWR1YWxzID0gKHRoaXMuc2hvd0luZGl2aWR1YWxzID09PSAnc2VsZWN0ZWQnKTtcclxuXHJcbiAgICB0aGlzLnNob3dBbGxJbmRpdmlkdWFscyA9ICh0aGlzLnNob3dJbmRpdmlkdWFscyA9PT0gJ2FsbCcpO1xyXG5cclxuICAgIHRoaXMudXBkYXRlUGxvdCgpO1xyXG5cclxuICB9XHJcblxyXG5cclxuICBuZ09uSW5pdCgpIHtcclxuXHJcbiAgICBpZiAodGhpcy5wYXJlbnROYXRpdmVFbGVtZW50ICE9PSBudWxsKSB7XHJcblxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgY29uc29sZS5lcnJvcignTWlzc2luZyBwYXJyZW50IGVsZW1lbnQgZm9yIHRoZSBjb21wb25lbnQnKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIG5nT25EZXN0cm95KCkge1xyXG4gICAgaWYgKHRoaXMuZDNTdmcgJiYgdGhpcy5kM1N2Zy5lbXB0eSAmJiAhdGhpcy5kM1N2Zy5lbXB0eSgpKSB7XHJcbiAgICAgIHRoaXMuZDNTdmcuc2VsZWN0QWxsKCcqJykucmVtb3ZlKCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuXHJcbiAgaW5pdGlhbGl6ZVN2ZygpOiBHcmFwaGljQ29udGV4dCB7XHJcblxyXG4gICAgY29uc3QgcFdpZHRoID0gNTAwO1xyXG4gICAgY29uc3QgcEhlaWdodCA9IDUwMDtcclxuXHJcbiAgICBjb25zdCBkM1BhcmVudEVsZW1lbnQgPSB0aGlzLmQzLnNlbGVjdCh0aGlzLnBhcmVudE5hdGl2ZUVsZW1lbnQpO1xyXG4gICAgdGhpcy5kM1N2ZyA9IGQzUGFyZW50RWxlbWVudC5zZWxlY3QoJy5wb2xhcnBsb3QnKS5hcHBlbmQoJ3N2ZycpO1xyXG5cclxuXHJcbiAgICB0aGlzLmQzU3ZnLmF0dHIoJ3dpZHRoJywgJzEwMCUnKVxyXG4gICAgICAuYXR0cigndmlld0JveCcsICcwIDAgJyArIHBXaWR0aCArICcgJyArIHBIZWlnaHQpO1xyXG5cclxuICAgIGNvbnN0IGNvbnRleHQgPSBuZXcgR3JhcGhpY0NvbnRleHQoKTtcclxuICAgIGNvbnRleHQubWFpblBhbmUgPSB0aGlzLmQzU3ZnLmFwcGVuZDxTVkdHRWxlbWVudD4oJ2cnKVxyXG4gICAgICAuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgnICsgKHBXaWR0aCAvIDIpICsgJywnICsgKHBIZWlnaHQgLyAyKSArICcpJyk7IC8vIG1vdmVzIDAsMCBvZiB0aGUgcGFpbiB0byB0aGUgbWlkZGxlIG9mIHRoZSBncmFwaGljc1xyXG5cclxuICAgIGNvbnRleHQucmFkaXVzID0gTWF0aC5taW4ocFdpZHRoLCBwSGVpZ2h0KSAvIDIgLSAzMDtcclxuICAgIHJldHVybiBjb250ZXh0O1xyXG4gIH1cclxuXHJcbiAgcHJlcGFyZUxlZ2VuZHRpcChjb250ZXh0OiBHcmFwaGljQ29udGV4dCk6IEdyYXBoaWNDb250ZXh0IHtcclxuXHJcbiAgICBpZiAoIWNvbnRleHQubGVnZW5kdGlwKSB7XHJcbiAgICAgIC8vIFNldCB1cCB0aGUgc21hbGwgdG9vbHRpcCBpbiB0aGUgY2VudHJlIGZvciB3aGVuIHlvdSBob3ZlciBvdmVyIGEgY2lyY2xlXHJcbiAgICAgIGNvbnRleHQubGVnZW5kdGlwID0gY29udGV4dC5tYWluUGFuZS5hcHBlbmQ8U1ZHR0VsZW1lbnQ+KCdnJylcclxuICAgICAgICAuY2xhc3NlZCgnbGVnZW5kdGlwV3JhcHBlcicsIHRydWUpIGFzIGFueTtcclxuXHJcbiAgICAgIGNvbnRleHQubGVnZW5kdGlwQm94ID0gY29udGV4dC5sZWdlbmR0aXAuYXBwZW5kPFNWR0dFbGVtZW50PigncmVjdCcpXHJcbiAgICAgICAgLnN0eWxlKCdmaWxsJywgJ3doaXRlJylcclxuICAgICAgICAuc3R5bGUoJ2ZpbGwtb3BhY2l0eScsIDAuOSlcclxuICAgICAgICAuc3R5bGUoJ3N0cm9rZScsICdncmV5JylcclxuICAgICAgO1xyXG5cclxuXHJcbiAgICAgIGNvbnRleHQubGVnZW5kdGlwVGV4dCA9IGNvbnRleHQubGVnZW5kdGlwLmFwcGVuZCgndGV4dCcpXHJcbiAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2xlZ2VuZHRpcCcpXHJcbiAgICAgICAgLmF0dHIoJ3RleHQtYW5jaG9yJywgJ21pZGRsZScpXHJcbiAgICAgICAgLy8gLmF0dHIoXCJkeVwiLCBcIjAuMzVlbVwiKVxyXG4gICAgICAgIC8vIC5zdHlsZShcImZvbnQtc2l6ZVwiLCB0aGlzLmxvb2tBbmRGZWVsLnRvb2x0aXBGb250U2l6ZSkgLy9cIjExcHhcIilcclxuICAgICAgICAuc3R5bGUoJ29wYWNpdHknLCAxKSBhcyBhbnlcclxuICAgICAgO1xyXG5cclxuICAgICAgY29udGV4dC5sZWdlbmR0aXBcclxuICAgICAgLy8gLnN0eWxlKFwidmlzaWJpbGl0eVwiLCBcImhpZGRlblwiKTtcclxuICAgICAgICAuc3R5bGUoJ2Rpc3BsYXknLCAnbm9uZScpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGNvbnRleHQ7XHJcbiAgfVxyXG5cclxuICBzaG93TGVnZW5kdGlwKHA6IFBldGFsTm9kZSwgcmFkaXVzOiBudW1iZXIpIHtcclxuXHJcbiAgICBpZiAoIXRoaXMubGFiZWxzT24pIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuZ3JhcGhpY0NvbnRleHQubGVnZW5kdGlwVGV4dFxyXG4gICAgICAuYXR0cigneCcsIDApXHJcbiAgICAgIC5hdHRyKCd5JywgMClcclxuICAgICAgLnRleHQocC5sYWJlbClcclxuICAgIC8vIC50cmFuc2l0aW9uKCkuZHVyYXRpb24odGhpcy5sb29rQW5kRmVlbC5iYXNlVHJhbnNpdGlvbnNUaW1lIC8gMilcclxuICAgIC8vIC5zdHlsZSgnb3BhY2l0eScsIDEpO1xyXG4gICAgO1xyXG5cclxuICAgIC8vIGl0IGhhcyB0byBiZSBiZWZvcmUgdGhlIGJveCBjYXVzZSBvZiB0aGUgYnVnIGluIGZpcmVmb3hcclxuICAgIHRoaXMuZ3JhcGhpY0NvbnRleHQubGVnZW5kdGlwXHJcbiAgICAgIC8vIC5zdHlsZShcInZpc2liaWxpdHlcIiwgXCJ2aXNpYmxlXCIpO1xyXG4gICAgICAuc3R5bGUoJ2Rpc3BsYXknLCBudWxsKTtcclxuXHJcbiAgICBjb25zdCBiYm94ID0gdGhpcy5ncmFwaGljQ29udGV4dC5sZWdlbmR0aXBUZXh0Lm5vZGUoKS5nZXRCQm94KCk7XHJcblxyXG4gICAgdGhpcy5ncmFwaGljQ29udGV4dC5sZWdlbmR0aXBCb3hcclxuICAgICAgLmF0dHIoJ3gnLCBiYm94LnggLSAzKVxyXG4gICAgICAuYXR0cigneScsIGJib3gueSAtIDIpXHJcbiAgICAgIC5hdHRyKCd3aWR0aCcsIGJib3gud2lkdGggKyA2KVxyXG4gICAgICAuYXR0cignaGVpZ2h0JywgYmJveC5oZWlnaHQgKyA0KTtcclxuXHJcblxyXG4gIH1cclxuXHJcbiAgaGlkZUxlZ2VuZHRpcCgpIHtcclxuXHJcbiAgICB0aGlzLmdyYXBoaWNDb250ZXh0LmxlZ2VuZHRpcFxyXG4gICAgLy8gLnN0eWxlKFwidmlzaWJpbGl0eVwiLCBcImhpZGRlblwiKTtcclxuICAgICAgLnN0eWxlKCdkaXNwbGF5JywgJ25vbmUnKTtcclxuICB9XHJcblxyXG5cclxuICBwcmVwYXJlVG9vbHRpcChjb250ZXh0OiBHcmFwaGljQ29udGV4dCk6IEdyYXBoaWNDb250ZXh0IHtcclxuXHJcbiAgICBpZiAoIWNvbnRleHQudG9vbHRpcCkge1xyXG4gICAgICAvLyBTZXQgdXAgdGhlIHNtYWxsIHRvb2x0aXAgZm9yIHdoZW4geW91IGhvdmVyIG92ZXIgYSBjaXJjbGVcclxuICAgICAgY29udGV4dC50b29sdGlwID0gY29udGV4dC5tYWluUGFuZS5hcHBlbmQ8U1ZHR0VsZW1lbnQ+KCdnJylcclxuICAgICAgICAuY2xhc3NlZCgndG9vbHRpcFdyYXBwZXInLCB0cnVlKSBhcyBhbnk7XHJcblxyXG4gICAgICBjb250ZXh0LnRvb2x0aXBCb3ggPSBjb250ZXh0LnRvb2x0aXAuYXBwZW5kPFNWR0dFbGVtZW50PigncmVjdCcpXHJcbiAgICAgICAgLnN0eWxlKCdmaWxsJywgJ3doaXRlJylcclxuICAgICAgICAuc3R5bGUoJ2ZpbGwtb3BhY2l0eScsIDAuOClcclxuICAgICAgICAuc3R5bGUoJ3N0cm9rZScsICdncmV5JylcclxuICAgICAgLy8gLnN0eWxlKFwidmlzaWJpbGl0eVwiLCBcImhpZGRlblwiKTtcclxuICAgICAgO1xyXG5cclxuXHJcbiAgICAgIGNvbnRleHQudG9vbHRpcFRleHQgPSBjb250ZXh0LnRvb2x0aXAuYXBwZW5kKCd0ZXh0JylcclxuICAgICAgICAuYXR0cignY2xhc3MnLCAndG9vbHRpcCcpXHJcbiAgICAgICAgLmF0dHIoJ3RleHQtYW5jaG9yJywgJ21pZGRsZScpXHJcbiAgICAgICAgLmF0dHIoJ2R5JywgJzAuMzVlbScpXHJcbiAgICAgICAgLy8gLnN0eWxlKFwiZm9udC1zaXplXCIsIHRoaXMubG9va0FuZEZlZWwudG9vbHRpcEZvbnRTaXplKSAvL1wiMTFweFwiKVxyXG4gICAgICAgIC5zdHlsZSgnb3BhY2l0eScsIDEpIGFzIGFueVxyXG4gICAgICA7XHJcblxyXG4gICAgICBjb250ZXh0LnRvb2x0aXBcclxuICAgICAgLy8gLnN0eWxlKFwidmlzaWJpbGl0eVwiLCBcImhpZGRlblwiKTtcclxuICAgICAgICAuc3R5bGUoJ2Rpc3BsYXknLCAnbm9uZScpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGNvbnRleHQ7XHJcbiAgfVxyXG5cclxuICBzaG93VG9vbHRpcChwOiBQZXRhbE5vZGUsIHJhZGl1czogbnVtYmVyKSB7XHJcblxyXG5cclxuICAgIHRoaXMuZ3JhcGhpY0NvbnRleHQudG9vbHRpcFRleHRcclxuICAgICAgLmF0dHIoJ3gnLCAocmFkaXVzICsgMTUpICogcC5wb2xhckNvb3JkaW5hdGVzWzBdKVxyXG4gICAgICAuYXR0cigneScsIChyYWRpdXMgKyAxNSkgKiBwLnBvbGFyQ29vcmRpbmF0ZXNbMV0pXHJcbiAgICAgIC50ZXh0KHAucm91bmRlZFBlYWspXHJcbiAgICAvLyAudHJhbnNpdGlvbigpLmR1cmF0aW9uKHRoaXMubG9va0FuZEZlZWwuYmFzZVRyYW5zaXRpb25zVGltZSAvIDIpXHJcbiAgICAvLyAuc3R5bGUoJ29wYWNpdHknLCAxKTtcclxuICAgIDtcclxuXHJcbiAgICAvLyBpdCBoYXMgdG8gYmUgYmVmb3JlIHRoZSBnZXQgQkJveCBjYXVzZSBvZiB0aGUgZmlyZWZveCBlcnJvcnNcclxuICAgIHRoaXMuZ3JhcGhpY0NvbnRleHQudG9vbHRpcFxyXG4gICAgICAvLyAuc3R5bGUoXCJ2aXNpYmlsaXR5XCIsIFwidmlzaWJsZVwiKTtcclxuICAgICAgLnN0eWxlKCdkaXNwbGF5JywgbnVsbCk7XHJcblxyXG4gICAgY29uc3QgYmJveCA9IHRoaXMuZ3JhcGhpY0NvbnRleHQudG9vbHRpcFRleHQubm9kZSgpLmdldEJCb3goKTtcclxuXHJcbiAgICB0aGlzLmdyYXBoaWNDb250ZXh0LnRvb2x0aXBCb3hcclxuICAgICAgLmF0dHIoJ3gnLCBiYm94LnggLSAzKVxyXG4gICAgICAuYXR0cigneScsIGJib3gueSAtIDIpXHJcbiAgICAgIC5hdHRyKCd3aWR0aCcsIGJib3gud2lkdGggKyA2KVxyXG4gICAgICAuYXR0cignaGVpZ2h0JywgYmJveC5oZWlnaHQgKyA0KTtcclxuXHJcblxyXG4gIH1cclxuXHJcbiAgaGlkZVRvb2x0aXAoKSB7XHJcbiAgICAvLyB0aGlzLmdyYXBoaWNDb250ZXh0LnRvb2x0aXBcclxuICAgIC8vIC50cmFuc2l0aW9uKCkuZHVyYXRpb24odGhpcy5sb29rQW5kRmVlbC5iYXNlVHJhbnNpdGlvbnNUaW1lIC8gMilcclxuICAgIC8vIC5zdHlsZShcIm9wYWNpdHlcIiwgMCk7XHJcblxyXG4gICAgdGhpcy5ncmFwaGljQ29udGV4dC50b29sdGlwXHJcbiAgICAvLyAuc3R5bGUoXCJ2aXNpYmlsaXR5XCIsIFwiaGlkZGVuXCIpO1xyXG4gICAgICAuc3R5bGUoJ2Rpc3BsYXknLCAnbm9uZScpO1xyXG4gIH1cclxuXHJcblxyXG4gIHVwZGF0ZVBsb3QoKSB7XHJcblxyXG4gICAgaWYgKCF0aGlzLmQzU3ZnKSB7XHJcbiAgICAgIHRoaXMuZ3JhcGhpY0NvbnRleHQgPSB0aGlzLmluaXRpYWxpemVTdmcoKTtcclxuXHJcbiAgICAgIHRoaXMuZ3JhcGhpY0NvbnRleHQgPSB0aGlzLnBsb3RBeGlzR3JpZCh0aGlzLmdyYXBoaWNDb250ZXh0KTtcclxuICAgIH1cclxuXHJcblxyXG4gICAgLy8gdGhlIGdyaWQgaXMgcGxvdHRlZCBvbmx5IG9uY2UsIG9ubHkgdGhlIGxhYmxlcyBhcmUgdXBkYXRlZFxyXG4gICAgdGhpcy51cGRhdGVBeGlzTGFiZWxzKHRoaXMuX2RvbWFpbiwgdGhpcy5ncmFwaGljQ29udGV4dC5heGlzR3JpZCk7XHJcblxyXG4gICAgdGhpcy5ncmFwaGljQ29udGV4dCA9IHRoaXMudXBkYXRlUGFsZXR0ZSh0aGlzLmRhdGEsIHRoaXMucGFsZXR0ZSwgdGhpcy5ncmFwaGljQ29udGV4dCk7XHJcblxyXG5cclxuICAgIGNvbnN0IHBldGFsTm9kZXMgPSB0aGlzLnByZXBhcmVEYXRhTW9kZWwodGhpcy5kYXRhLCB0aGlzLl9kb21haW4sIHRoaXMuc2NhbGVSYWRpdXMsIHRoaXMuc2NhbGVXaWR0aCwgdGhpcy5lcnJvcnMsXHJcbiAgICAgIHRoaXMubGFiZWxzLCB0aGlzLnJlbW92ZWQsIHRoaXMuZ3JhcGhpY0NvbnRleHQucGFsZXR0ZSk7XHJcblxyXG5cclxuICAgIC8vdGhpcy5pbmRpdmlkdWFsUG9sYXJEYXRhID0gdGhpcy5wcmVwYXJlSW5kaXZpZHVhbFBvbGFyRGF0YSh0aGlzLmRhdGEsIHRoaXMuX2RvbWFpbiwgdGhpcy5yZW1vdmVkLCB0aGlzLmdyYXBoaWNDb250ZXh0LnBhbGV0dGUpO1xyXG4gICAgLy90aGlzLmluZGl2aWR1YWxQb2xhckRhdGEgPSB0aGlzLmluZGl2aWR1YWxQb2xhckRhdGEuZmlsdGVyKGQgPT4gZC5sZW5ndGggIT09IDApO1xyXG5cclxuICAgIHRoaXMuZ3JhcGhpY0NvbnRleHQgPSB0aGlzLnBsb3REYXRhUGV0YWxzKHBldGFsTm9kZXMsIHRoaXMuc2NhbGVSYWRpdXMsIHRoaXMuc2NhbGVXaWR0aCwgdGhpcy5ncmFwaGljQ29udGV4dCk7XHJcblxyXG4gICAgdGhpcy5ncmFwaGljQ29udGV4dCA9IHRoaXMucGxvdEFsbERhdGFEb3RzKHBldGFsTm9kZXMsIHRoaXMuc2hvd0FsbEluZGl2aWR1YWxzLCB0aGlzLmdyYXBoaWNDb250ZXh0KTtcclxuXHJcbiAgICB0aGlzLmdyYXBoaWNDb250ZXh0ID0gdGhpcy5wcmVwYXJlSW5kaXZpZHVhbERhdGFJbnNldCh0aGlzLmdyYXBoaWNDb250ZXh0KTtcclxuXHJcbiAgICB0aGlzLmdyYXBoaWNDb250ZXh0ID0gdGhpcy5wcmVwYXJlVG9vbHRpcCh0aGlzLmdyYXBoaWNDb250ZXh0KTtcclxuICAgIHRoaXMuZ3JhcGhpY0NvbnRleHQgPSB0aGlzLnByZXBhcmVMZWdlbmR0aXAodGhpcy5ncmFwaGljQ29udGV4dCk7XHJcblxyXG4gIH1cclxuXHJcbiAgcHJlcGFyZURhdGFNb2RlbChkYXRhR3JvdXBzOiBudW1iZXJbXVtdLCBkb21haW46IG51bWJlcltdLFxyXG4gICAgICAgICAgICAgICAgICAgc2NhbGVSYWRpdXM6IGJvb2xlYW4sIHNjYWxlV2lkdGg6IGJvb2xlYW4sIGVycm9yczogbnVtYmVyW10sXHJcbiAgICAgICAgICAgICAgICAgICBsYWJlbHM6IHN0cmluZ1tdLCByZW1vdmVkOiBudW1iZXJbXSxcclxuICAgICAgICAgICAgICAgICAgIHBhbGV0dGU6IHN0cmluZ1tdKTogUGV0YWxOb2RlW10ge1xyXG5cclxuICAgIGxldCBwZXRhbE5vZGVzID0gdGhpcy5wb2xhclV0aWwuZGF0YVRvUGV0YWxzKHRoaXMuZGF0YSwgdGhpcy5fZG9tYWluLCB0aGlzLnNjYWxlUmFkaXVzLCB0aGlzLnNjYWxlV2lkdGgsIHRoaXMuZXJyb3JzKTtcclxuXHJcbiAgICB0aGlzLmxhYmVsUGV0YWxzKHBldGFsTm9kZXMsIGxhYmVscyk7XHJcbiAgICB0aGlzLmNvbG9yUGV0YWxzKHBldGFsTm9kZXMsIHBhbGV0dGUpO1xyXG4gICAgLy8gbWFyayBoaWRkZW5cclxuICAgIHJlbW92ZWQuZm9yRWFjaCggaXggPT4ge1xyXG4gICAgICBpZiAocGV0YWxOb2Rlc1tpeF0pIHtcclxuICAgICAgICBwZXRhbE5vZGVzW2l4XS5oaWRkZW4gPSB0cnVlO1xyXG4gICAgICAgIHBldGFsTm9kZXNbaXhdLmluZGl2aWR1YWxzLmZvckVhY2goIHAgPT4gcC5oaWRkZW4gPSB0cnVlKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICAvLyBwZXRhbE5vZGVzID0gcGV0YWxOb2Rlcy5maWx0ZXIobiA9PiAhbi5oaWRkZW4pO1xyXG5cclxuICAgIC8vIHJlbW92ZSBlbXB0eSBkYXRhXHJcbiAgICBwZXRhbE5vZGVzID0gcGV0YWxOb2Rlcy5maWx0ZXIobiA9PiAhaXNOYU4obi5wZWFrKSk7XHJcbiAgICByZXR1cm4gcGV0YWxOb2RlcztcclxuICB9XHJcblxyXG4gIHVwZGF0ZVBhbGV0dGUoZGF0YTogYW55W10sIHBhbGV0dGU6IHN0cmluZ1tdLCBjb250ZXh0OiBHcmFwaGljQ29udGV4dCk6IEdyYXBoaWNDb250ZXh0IHtcclxuICAgIGlmICghcGFsZXR0ZSB8fCBwYWxldHRlLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICBjb250ZXh0LnBhbGV0dGUgPSBCRDJDb2xvclBhbGV0dGUucGFsZXR0ZShkYXRhLmxlbmd0aCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBjb250ZXh0LnBhbGV0dGUgPSBCRDJDb2xvclBhbGV0dGUuZXh0ZW5kUGFsZXR0ZShwYWxldHRlLCBkYXRhLmxlbmd0aCk7XHJcblxyXG4gICAgfVxyXG4gICAgdGhpcy5jb2xvcnMubmV4dChjb250ZXh0LnBhbGV0dGUuc2xpY2UoKSk7XHJcbiAgICByZXR1cm4gY29udGV4dDtcclxuICB9XHJcblxyXG4gIGxhYmVsUGV0YWxzKHBldGFsczogUGV0YWxOb2RlW10sIGxhYmVsczogc3RyaW5nW10pIHtcclxuICAgIGlmICghbGFiZWxzKSB7XHJcbiAgICAgIGxhYmVscyA9IFtdO1xyXG4gICAgfVxyXG5cclxuICAgIHBldGFscy5mb3JFYWNoKChuLCBpeCkgPT4gbi5sYWJlbCA9IGxhYmVsc1tpeF0gPyBsYWJlbHNbaXhdIDogJycgKyAoaXggKyAxKSk7XHJcbiAgfVxyXG5cclxuICBjb2xvclBldGFscyhwZXRhbHM6IFBldGFsTm9kZVtdLCBwYWxldHRlOiBzdHJpbmdbXSkge1xyXG4gICAgcGV0YWxzLmZvckVhY2goKGIsIGl4KSA9PiB7XHJcbiAgICAgIGIuY29sb3IgPSBwYWxldHRlW2l4XTtcclxuICAgICAgYi5pbmRpdmlkdWFscy5mb3JFYWNoKCBwID0+IHAuY29sb3IgPSBiLmNvbG9yKTtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgcGxvdERhdGFQZXRhbHMocGV0YWxOb2RlczogUGV0YWxOb2RlW10sXHJcbiAgICAgICAgICAgICAgICAgc2NhbGVSYWRpdXM6IGJvb2xlYW4sIHNjYWxlV2lkdGg6IGJvb2xlYW4sXHJcbiAgICAgICAgICAgICAgICAgY29udGV4dDogR3JhcGhpY0NvbnRleHQpOiBHcmFwaGljQ29udGV4dCB7XHJcblxyXG4gICAgY29uc3QgdHJhbnNpdGlvbnNUaW1lID0gdGhpcy5sb29rQW5kRmVlbC5iYXNlVHJhbnNpdGlvbnNUaW1lO1xyXG4gICAgY29uc3QgZDMgPSB0aGlzLmQzO1xyXG4gICAgY29uc3QgcmFkaXVzID0gY29udGV4dC5yYWRpdXM7XHJcblxyXG4gICAgaWYgKCFjb250ZXh0LnBldGFsc1dyYXBwZXIpIHtcclxuICAgICAgY29udGV4dC5wZXRhbHNXcmFwcGVyID0gY29udGV4dC5tYWluUGFuZS5hcHBlbmQ8U1ZHR0VsZW1lbnQ+KCdnJykuYXR0cignY2xhc3MnLCAncGV0YWxzV3JhcHBlcicpO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHBldGFsc1dyYXBwZXIgPSBjb250ZXh0LnBldGFsc1dyYXBwZXI7XHJcblxyXG4gICAgY29uc3QgcGV0YWxMaW5lID0gKHA6IFBldGFsTm9kZSkgPT4ge1xyXG5cclxuICAgICAgcmV0dXJuIGQzLmxpbmVSYWRpYWwoKVxyXG4gICAgICAgIC5yYWRpdXMoZnVuY3Rpb24oZCkge1xyXG4gICAgICAgICAgcmV0dXJuIHJhZGl1cyAqIGRbMF07XHJcbiAgICAgICAgfSlcclxuICAgICAgICAuYW5nbGUoZnVuY3Rpb24oZCkge1xyXG4gICAgICAgICAgcmV0dXJuIGRbMV07XHJcbiAgICAgICAgfSlcclxuICAgICAgICAuY3VydmUoZDMuY3VydmVDYXJkaW5hbENsb3NlZCkocC5wZXRhbFBhdGggYXMgYW55KTtcclxuICAgIH07XHJcblxyXG4gICAgY29uc3QgaW5zdGFuY2UgPSB0aGlzO1xyXG5cclxuICAgIC8vIHNvIHRoYXQgYW5ndWxhciBjaGFuZ2UgZGV0ZWN0aW9uIGlzIG5vdCB0cmlnZ2VyZWQgZm9yIG1vdXNlb3Zlci9vdXIgZXZlbnRzIG9yIHRyYW5zaXRpb25zXHJcbiAgICB0aGlzLm5nWm9uZS5ydW5PdXRzaWRlQW5ndWxhcigoKSA9PiB7XHJcblxyXG4gICAgICBjb25zdCBwZXRhbHMgPSBwZXRhbHNXcmFwcGVyLnNlbGVjdEFsbCgnLnBldGFsJylcclxuICAgICAgICAuZGF0YShwZXRhbE5vZGVzKTtcclxuXHJcblxyXG4gICAgICBjb25zdCBwZXRhbEFyZWFPcGFjaXR5ID0gdGhpcy5sb29rQW5kRmVlbC5wZXRhbEFyZWFPcGFjaXR5O1xyXG5cclxuICAgICAgcGV0YWxzXHJcbiAgICAgICAgLnNlbGVjdCgnLnBldGFsc0FyZWEnKVxyXG4gICAgICAgIC50cmFuc2l0aW9uKCkuZHVyYXRpb24odHJhbnNpdGlvbnNUaW1lKVxyXG4gICAgICAgIC5hdHRyKCdkJywgcGV0YWxMaW5lIGFzIGFueSlcclxuICAgICAgICAuc3R5bGUoJ2ZpbGwnLCBkID0+IGQuY29sb3IpXHJcbiAgICAgICAgLnN0eWxlKCdmaWxsLW9wYWNpdHknLCB0aGlzLmxvb2tBbmRGZWVsLnBldGFsQXJlYU9wYWNpdHkpXHJcbiAgICAgICAgLm9uKCdpbnRlcnJ1cHQnLCBmdW5jdGlvbihkOiBQZXRhbE5vZGUpIHtcclxuICAgICAgICAgIGQzLnNlbGVjdCh0aGlzKVxyXG4gICAgICAgICAgICAuYXR0cignZCcsIHBldGFsTGluZSBhcyBhbnkpXHJcbiAgICAgICAgICAgIC5zdHlsZSgnZmlsbCcsIF8gPT4gZC5jb2xvcilcclxuICAgICAgICAgICAgLnN0eWxlKCdmaWxsLW9wYWNpdHknLCBwZXRhbEFyZWFPcGFjaXR5KTtcclxuICAgICAgICB9KVxyXG4gICAgICA7XHJcblxyXG4gICAgICBwZXRhbHNcclxuICAgICAgICAuc2VsZWN0KCcucGV0YWxzTGluZScpXHJcbiAgICAgICAgLnRyYW5zaXRpb24oKS5kdXJhdGlvbih0cmFuc2l0aW9uc1RpbWUpXHJcbiAgICAgICAgLmF0dHIoJ2QnLCBwZXRhbExpbmUgYXMgYW55KVxyXG4gICAgICAgIC5zdHlsZSgnc3Ryb2tlJywgZCA9PiBkLmNvbG9yKVxyXG4gICAgICAgIC5zdHlsZSgnc3Ryb2tlLW9wYWNpdHknLCAxKVxyXG4gICAgICAgIC5zdHlsZSgnc3Ryb2tlLXdpZHRoJywgdGhpcy5sb29rQW5kRmVlbC5wZXRhbExpbmVXaWR0aClcclxuICAgICAgICAub24oJ2ludGVycnVwdCcsIGZ1bmN0aW9uKCBkOiBQZXRhbE5vZGUpIHtcclxuICAgICAgICAgIGQzLnNlbGVjdCh0aGlzKVxyXG4gICAgICAgICAgICAuYXR0cignZCcsIHBldGFsTGluZSBhcyBhbnkpXHJcbiAgICAgICAgICAgIC5zdHlsZSgnc3Ryb2tlJywgXyA9PiBkLmNvbG9yKVxyXG4gICAgICAgICAgICAuc3R5bGUoJ3N0cm9rZS1vcGFjaXR5JywgMSk7XHJcbiAgICAgICAgfSlcclxuICAgICAgO1xyXG5cclxuICAgICAgcGV0YWxzXHJcbiAgICAgICAgLnNlbGVjdCgnLnBldGFsc0NpcmNsZScpXHJcbiAgICAgICAgLnRyYW5zaXRpb24oKS5kdXJhdGlvbih0cmFuc2l0aW9uc1RpbWUpXHJcbiAgICAgICAgLmF0dHIoJ2N4JywgZnVuY3Rpb24oZDogUGV0YWxOb2RlLCBpKSB7XHJcbiAgICAgICAgICByZXR1cm4gcmFkaXVzICogZC5wb2xhckNvb3JkaW5hdGVzWzBdOyAvLyBNYXRoLmNvcyhkICogMiAqIE1hdGguUEkgLyAyNCAtIE1hdGguUEkgLyAyKTtcclxuICAgICAgICB9KVxyXG4gICAgICAgIC5hdHRyKCdjeScsIGZ1bmN0aW9uKGQ6IFBldGFsTm9kZSwgaSkge1xyXG4gICAgICAgICAgcmV0dXJuIHJhZGl1cyAqIGQucG9sYXJDb29yZGluYXRlc1sxXTsgLy8gTWF0aC5zaW4oZCAqIDIgKiBNYXRoLlBJIC8gMjQgLSBNYXRoLlBJIC8gMik7XHJcbiAgICAgICAgfSlcclxuICAgICAgICAuc3R5bGUoJ2ZpbGwnLCBkID0+IGQuY29sb3IpXHJcbiAgICAgICAgLm9uKCdpbnRlcnJ1cHQnLCBmdW5jdGlvbihkOiBQZXRhbE5vZGUpIHtcclxuICAgICAgICAgIGQzLnNlbGVjdCh0aGlzKVxyXG4gICAgICAgICAgICAuYXR0cignY3gnLCBmdW5jdGlvbihfOiBQZXRhbE5vZGUsIGkpIHtcclxuICAgICAgICAgICAgICByZXR1cm4gcmFkaXVzICogZC5wb2xhckNvb3JkaW5hdGVzWzBdOyAvLyBNYXRoLmNvcyhkICogMiAqIE1hdGguUEkgLyAyNCAtIE1hdGguUEkgLyAyKTtcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgLmF0dHIoJ2N5JywgZnVuY3Rpb24oXzogUGV0YWxOb2RlLCBpKSB7XHJcbiAgICAgICAgICAgICAgcmV0dXJuIHJhZGl1cyAqIGQucG9sYXJDb29yZGluYXRlc1sxXTsgLy8gTWF0aC5zaW4oZCAqIDIgKiBNYXRoLlBJIC8gMjQgLSBNYXRoLlBJIC8gMik7XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5zdHlsZSgnZmlsbCcsIF8gPT4gZC5jb2xvcik7XHJcbiAgICAgICAgfSlcclxuICAgICAgO1xyXG5cclxuICAgICAgY29uc3QgbmV3UGV0YWxzID0gcGV0YWxzXHJcbiAgICAgICAgLmVudGVyKClcclxuICAgICAgICAuYXBwZW5kPFNWR0dFbGVtZW50PignZycpXHJcbiAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ3BldGFsJyk7XHJcblxyXG5cclxuICAgICAgY29uc3QgcGV0YWxzQXJlYSA9IG5ld1BldGFscy5hcHBlbmQoJ3BhdGgnKTtcclxuXHJcbiAgICAgIHBldGFsc0FyZWFcclxuICAgICAgICAuYXR0cignY2xhc3MnLCAncGV0YWxzQXJlYScpXHJcbiAgICAgICAgLmF0dHIoJ2QnLCBwZXRhbExpbmUgYXMgYW55KVxyXG4gICAgICAgIC5zdHlsZSgnZmlsbCcsIGQgPT4gZC5jb2xvcilcclxuICAgICAgICAuc3R5bGUoJ2ZpbGwtb3BhY2l0eScsIDApXHJcbiAgICAgICAgLm9uKCdtb3VzZW92ZXInLCBmdW5jdGlvbihldnQ6IE1vdXNlRXZlbnQsIGQ6IFBldGFsTm9kZSkge1xyXG5cclxuICAgICAgICAgIGQzLnNlbGVjdCh0aGlzKVxyXG4gICAgICAgICAgICAudHJhbnNpdGlvbigpLmR1cmF0aW9uKHRyYW5zaXRpb25zVGltZSlcclxuICAgICAgICAgICAgLnN0eWxlKCdmaWxsLW9wYWNpdHknLCBpbnN0YW5jZS5sb29rQW5kRmVlbC5wZXRhbEFyZWFPcGFjaXR5QWN0aXZlKTtcclxuXHJcbiAgICAgICAgICBpbnN0YW5jZS5zaG93VG9vbHRpcChkLCByYWRpdXMpO1xyXG4gICAgICAgICAgaW5zdGFuY2Uuc2hvd0xlZ2VuZHRpcChkLCByYWRpdXMpO1xyXG5cclxuICAgICAgICAgIC8qY29uc3QgZSA9IHBldGFsc0FyZWEubm9kZXMoKTtcclxuICAgICAgICAgIGNvbnNvbGUubG9nKFwiTm9kZXNcIixlKTtcclxuICAgICAgICAgIGNvbnNvbGUubG9nKFwiVFwiLCB0aGlzKTtcclxuICAgICAgICAgIGNvbnNvbGUubG9nKFwiU1wiLGQzLnNlbGVjdCh0aGlzKSk7XHJcbiAgICAgICAgICBjb25zdCBpeCA9IGUuaW5kZXhPZih0aGlzKTtcclxuICAgICAgICAgICovXHJcblxyXG4gICAgICAgICAgaW5zdGFuY2Uuc2hvd0luZGl2aWR1YWxEYXRhSW5zZXQoZCwgcmFkaXVzKTtcclxuXHJcbiAgICAgICAgfSlcclxuICAgICAgICAub24oJ21vdXNlb3V0JywgZnVuY3Rpb24oKSB7XHJcblxyXG4gICAgICAgICAgZDMuc2VsZWN0KHRoaXMpXHJcbiAgICAgICAgICAgIC50cmFuc2l0aW9uKCkuZHVyYXRpb24odHJhbnNpdGlvbnNUaW1lKVxyXG4gICAgICAgICAgICAuc3R5bGUoJ2ZpbGwtb3BhY2l0eScsIGluc3RhbmNlLmxvb2tBbmRGZWVsLnBldGFsQXJlYU9wYWNpdHkpO1xyXG5cclxuICAgICAgICAgIGluc3RhbmNlLmhpZGVUb29sdGlwKCk7XHJcbiAgICAgICAgICBpbnN0YW5jZS5oaWRlTGVnZW5kdGlwKCk7XHJcbiAgICAgICAgICBpbnN0YW5jZS5oaWRlSW5kaXZpZHVhbERhdGFJbnNldCgpO1xyXG5cclxuICAgICAgICB9KVxyXG4gICAgICAgIC50cmFuc2l0aW9uKCkuZHVyYXRpb24odHJhbnNpdGlvbnNUaW1lKVxyXG4gICAgICAgIC5zdHlsZSgnZmlsbC1vcGFjaXR5JywgdGhpcy5sb29rQW5kRmVlbC5wZXRhbEFyZWFPcGFjaXR5KVxyXG4gICAgICA7XHJcblxyXG4gICAgICBuZXdQZXRhbHNcclxuICAgICAgICAuYXBwZW5kKCdwYXRoJylcclxuICAgICAgICAuc3R5bGUoJ3N0cm9rZS1vcGFjaXR5JywgMClcclxuICAgICAgICAudHJhbnNpdGlvbigpLmR1cmF0aW9uKHRyYW5zaXRpb25zVGltZSlcclxuICAgICAgICAuYXR0cignY2xhc3MnLCAncGV0YWxzTGluZScpXHJcbiAgICAgICAgLmF0dHIoJ2QnLCBwZXRhbExpbmUgYXMgYW55KVxyXG4gICAgICAgIC5zdHlsZSgnc3Ryb2tlLXdpZHRoJywgdGhpcy5sb29rQW5kRmVlbC5wZXRhbExpbmVXaWR0aClcclxuICAgICAgICAuc3R5bGUoJ3N0cm9rZScsIGQgPT4gZC5jb2xvcilcclxuICAgICAgICAuc3R5bGUoJ2ZpbGwnLCAnbm9uZScpXHJcbiAgICAgICAgLnN0eWxlKCdzdHJva2Utb3BhY2l0eScsIDEpXHJcbiAgICAgIDtcclxuICAgICAgLy8gLnN0eWxlKFwiZmlsdGVyXCIgLCBcInVybCgjZ2xvdylcIik7XHJcblxyXG4gICAgICAvLyBBcHBlbmQgdGhlIGNpcmNsZXNcclxuICAgICAgbmV3UGV0YWxzXHJcbiAgICAgICAgLmFwcGVuZCgnY2lyY2xlJylcclxuICAgICAgICAuYXR0cignY2xhc3MnLCAncGV0YWxzQ2lyY2xlJylcclxuICAgICAgICAuYXR0cignY3gnLCBmdW5jdGlvbihkOiBQZXRhbE5vZGUsIGkpIHtcclxuICAgICAgICAgIHJldHVybiByYWRpdXMgKiBkLnBvbGFyQ29vcmRpbmF0ZXNbMF07IC8vIE1hdGguY29zKGQgKiAyICogTWF0aC5QSSAvIDI0IC0gTWF0aC5QSSAvIDIpO1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgLmF0dHIoJ2N5JywgZnVuY3Rpb24oZDogUGV0YWxOb2RlLCBpKSB7XHJcbiAgICAgICAgICByZXR1cm4gcmFkaXVzICogZC5wb2xhckNvb3JkaW5hdGVzWzFdOyAvLyBNYXRoLnNpbihkICogMiAqIE1hdGguUEkgLyAyNCAtIE1hdGguUEkgLyAyKTtcclxuICAgICAgICB9KVxyXG4gICAgICAgIC5hdHRyKCdyJywgdGhpcy5sb29rQW5kRmVlbC5wZXRhbENpcmNsZVJhZGl1cylcclxuICAgICAgICAuc3R5bGUoJ2ZpbGwnLCBkID0+IGQuY29sb3IpXHJcbiAgICAgICAgLnN0eWxlKCdmaWxsLW9wYWNpdHknLCB0aGlzLmxvb2tBbmRGZWVsLnBldGFsQ2lyY2xlT3BhY2l0eSk7XHJcblxyXG4gICAgICBwZXRhbHMuZXhpdCgpXHJcbiAgICAgICAgLy8gLnRyYW5zaXRpb24oKS5kdXJhdGlvbih0cmFuc2l0aW9uc1RpbWUgLyAyKVxyXG4gICAgICAgIC8vIC5zdHlsZSgnb3BhY2l0eScsIDAuMClcclxuICAgICAgICAucmVtb3ZlKCk7XHJcblxyXG4gICAgICBjb25zdCBwZXRhbHNBbGw6IFNlbGVjdGlvbjxTVkdHRWxlbWVudCwgUGV0YWxOb2RlLCBudWxsLCB1bmRlZmluZWQ+ID0gcGV0YWxzV3JhcHBlci5zZWxlY3RBbGwoJy5wZXRhbCcpXHJcbiAgICAgICAgLy8gLnN0eWxlKFwidmlzaWJpbGl0eVwiLCAobjpQZXRhbE5vZGUpID0+IG4uaGlkZGVuID8gXCJoaWRkZW5cIjpcInZpc2libGVcIik7XHJcbiAgICAgICAgLnN0eWxlKCdkaXNwbGF5JywgKG46IFBldGFsTm9kZSkgPT4gbi5oaWRkZW4gPyAnbm9uZScgOiBudWxsKSBhcyBhbnk7XHJcblxyXG4gICAgfSk7XHJcblxyXG4gICAgcmV0dXJuIGNvbnRleHQ7XHJcbiAgfVxyXG5cclxuICAvKlxyXG4gIHByZXBhcmVJbmRpdmlkdWFsUG9sYXJEYXRhKGRhdGFHcm91cHM6IG51bWJlcltdW10sIGRvbWFpbjogbnVtYmVyW10sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlZDogbnVtYmVyW10sIHBhbGV0dGU6IHN0cmluZ1tdKTogUG9sYXJQb2ludFtdW10ge1xyXG4gICAgLy8gYXBwZW5kIGdyb3VwIGluZGV4IHRvIHRoZSBkYXRhIHNvIHRoZSBjb2xvcnMgY2FuIGJlIGdlbmVyYXRlZCBmb3IgZWFjaCBkYXRhIHBvaW50IChpeCBpcyBmb3IgdGhlIHBhcnJlbnQgc28gaXQgd291bGRcclxuICAgIC8vIG5vdCBiZSBhdmFpbGFibGVcclxuICAgIGNvbnN0IGluZCA9IGRhdGFHcm91cHMubWFwKChnLCBpeCkgPT4gZy5tYXAoYSA9PiB7XHJcbiAgICAgIGNvbnN0IHYgPSBuZXcgUG9sYXJQb2ludCh0aGlzLnBvbGFyVXRpbC5jYWxjdWxhdGVQb2xhckNvb3JkaW5hdGUoYSwgZG9tYWluKSwgcGFsZXR0ZVtpeF0pO1xyXG4gICAgICByZXR1cm4gdjtcclxuICAgIH0pKTtcclxuICAgIHJlbW92ZWQuZm9yRWFjaCAoaXggPT4ge1xyXG4gICAgICBpZiAoaW5kW2l4XSkge1xyXG4gICAgICAgIGluZFtpeF0uZm9yRWFjaChwID0+IHAuaGlkZGVuID0gdHJ1ZSk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIGluZDtcclxuICB9Ki9cclxuXHJcbiAgcHJlcGFyZUluZGl2aWR1YWxEYXRhSW5zZXQoY29udGV4dDogR3JhcGhpY0NvbnRleHQpOiBHcmFwaGljQ29udGV4dCB7XHJcblxyXG4gICAgaWYgKCFjb250ZXh0LmluZGl2aWR1YWxEb3RzSW5zZXRXcmFwcGVyKSB7XHJcbiAgICAgIGNvbnRleHQuaW5kaXZpZHVhbERvdHNJbnNldFdyYXBwZXIgPSBjb250ZXh0Lm1haW5QYW5lLmFwcGVuZDxTVkdHRWxlbWVudD4oJ2cnKS5hdHRyKCdjbGFzcycsICdkb3RzSW5zZXQnKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyB0aGUgYWN0dWFsIHBsb3R0aW5nIGhhcHBlbnMgaW4gc2hvd0luZGl2aWR1YWxzIGFzIGl0IGlzIGRhdGEgZGVwZW5kZWRcclxuXHJcbiAgICAvLyB3ZSBhbHdheXMgaGlkZSBpdCB3aXRoIG5ldyBkYXRhIGZpcnN0O1xyXG4gICAgdGhpcy5oaWRlSW5kaXZpZHVhbERhdGFJbnNldCgpO1xyXG4gICAgcmV0dXJuIGNvbnRleHQ7XHJcbiAgfVxyXG5cclxuICBoaWRlSW5kaXZpZHVhbERhdGFJbnNldCgpIHtcclxuICAgIGlmICghdGhpcy5ncmFwaGljQ29udGV4dC5pbmRpdmlkdWFsRG90c0luc2V0V3JhcHBlcikge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5ncmFwaGljQ29udGV4dC5pbmRpdmlkdWFsRG90c0luc2V0V3JhcHBlclxyXG4gICAgICAuc3R5bGUoJ29wYWNpdHknLCAwLjApO1xyXG4gIH1cclxuXHJcbiAgc2hvd0luZGl2aWR1YWxEYXRhSW5zZXQocDogUGV0YWxOb2RlLCByYWRpdXM6IG51bWJlcikge1xyXG5cclxuICAgIGlmICghdGhpcy5ncmFwaGljQ29udGV4dC5pbmRpdmlkdWFsRG90c0luc2V0V3JhcHBlciB8fCAhcC5pbmRpdmlkdWFscyB8fCAhdGhpcy5zaG93U2VsZWN0ZWRJbmRpdmlkdWFscykge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgLy8gY29uc29sZS5sb2coXCJQOiBcIitwLnBvbGFyQ29vcmRpbmF0ZXNbMF0sIHAucG9sYXJDb29yZGluYXRlcyk7XHJcblxyXG4gICAgY29uc3QgdHJhbnNpdGlvbnNUaW1lID0gdGhpcy5sb29rQW5kRmVlbC5iYXNlVHJhbnNpdGlvbnNUaW1lIC8gMjtcclxuXHJcbiAgICBjb25zdCBkMyA9IHRoaXMuZDM7XHJcblxyXG4gICAgLy8gY29uc29sZS5sb2coXCJJeFwiLGl4KTtcclxuICAgIC8vIGNvbnNvbGUubG9nKFwiRFwiLHRoaXMuaW5kaXZpZHVhbFBvbGFyRGF0YVtpeF0pO1xyXG4gICAgY29uc3QgaW5kaXZpZHVhbHMgPSBwLmluZGl2aWR1YWxzOyAvLyB0aGlzLmluZGl2aWR1YWxQb2xhckRhdGFbaXhdO1xyXG5cclxuXHJcbiAgICBjb25zdCBkb3RzID0gdGhpcy5ncmFwaGljQ29udGV4dC5pbmRpdmlkdWFsRG90c0luc2V0V3JhcHBlci5zZWxlY3RBbGwoJy5kb3RzQ2lyY2xlJylcclxuICAgICAgLmRhdGEoaW5kaXZpZHVhbHMpO1xyXG5cclxuICAgIC8vIGV4aXN0aW5nIGRvdHNcclxuICAgIGRvdHNcclxuICAgICAgLmludGVycnVwdCgpXHJcbiAgICAgIC5zdHlsZSgnb3BhY2l0eScsIDAuMilcclxuICAgICAgLmF0dHIoJ2N4JywgcmFkaXVzICogcC5wb2xhckNvb3JkaW5hdGVzWzBdKVxyXG4gICAgICAuYXR0cignY3knLCByYWRpdXMgKiBwLnBvbGFyQ29vcmRpbmF0ZXNbMV0pXHJcbiAgICAgIC5zdHlsZSgnc3Ryb2tlJywgcC5jb2xvcilcclxuICAgICAgLnN0eWxlKCdmaWxsJywgcC5jb2xvcilcclxuICAgICAgLnRyYW5zaXRpb24oKS5kdXJhdGlvbih0cmFuc2l0aW9uc1RpbWUpXHJcbiAgICAgIC5zdHlsZSgnb3BhY2l0eScsIDEpXHJcbiAgICAgIC5hdHRyKCdjeCcsIGQgPT4gcmFkaXVzICogZC54eVswXSlcclxuICAgICAgLmF0dHIoJ2N5JywgZCA9PiByYWRpdXMgKiBkLnh5WzFdKSAvLyBNYXRoLnNpbihkICogMiAqIE1hdGguUEkgLyAyNCAtIE1hdGguUEkgLyAyKTtcclxuICAgIDtcclxuXHJcbiAgICAvLyBuZXcgZG90c1xyXG4gICAgZG90cy5lbnRlcigpXHJcbiAgICAgIC5hcHBlbmQoJ2NpcmNsZScpXHJcbiAgICAgIC5zdHlsZSgnb3BhY2l0eScsIDAuMilcclxuICAgICAgLmF0dHIoJ2NsYXNzJywgJ2RvdHNDaXJjbGUnKVxyXG4gICAgICAuYXR0cignY3gnLCByYWRpdXMgKiBwLnBvbGFyQ29vcmRpbmF0ZXNbMF0pXHJcbiAgICAgIC5hdHRyKCdjeScsIHJhZGl1cyAqIHAucG9sYXJDb29yZGluYXRlc1sxXSlcclxuICAgICAgLmF0dHIoJ3InLCB0aGlzLmxvb2tBbmRGZWVsLmRvdHNDaXJjbGVSYWRpdXMpXHJcbiAgICAgIC5zdHlsZSgnc3Ryb2tlLXdpZHRoJywgdGhpcy5sb29rQW5kRmVlbC5kb3RzQ2lyY2xlU3Ryb2tlV2lkdGgpXHJcbiAgICAgIC5zdHlsZSgnc3Ryb2tlJywgcC5jb2xvcilcclxuICAgICAgLnN0eWxlKCdmaWxsJywgcC5jb2xvcilcclxuICAgICAgLnN0eWxlKCdmaWxsLW9wYWNpdHknLCB0aGlzLmxvb2tBbmRGZWVsLmRvdHNDaXJjbGVGaWxsT3BhY2l0eSlcclxuICAgICAgLnRyYW5zaXRpb24oKS5kdXJhdGlvbih0cmFuc2l0aW9uc1RpbWUpXHJcbiAgICAgIC5zdHlsZSgnb3BhY2l0eScsIDEpXHJcbiAgICAgIC5hdHRyKCdjeCcsIGQgPT4gcmFkaXVzICogZC54eVswXSlcclxuICAgICAgLmF0dHIoJ2N5JywgZCA9PiByYWRpdXMgKiBkLnh5WzFdKSAvLyBNYXRoLnNpbihkICogMiAqIE1hdGguUEkgLyAyNCAtIE1hdGguUEkgLyAyKTtcclxuICAgIDtcclxuICAgIC8vIGV4aXRcclxuICAgIGRvdHMuZXhpdCgpXHJcbiAgICAgIC5yZW1vdmUoKTtcclxuXHJcbiAgICB0aGlzLmdyYXBoaWNDb250ZXh0LmluZGl2aWR1YWxEb3RzSW5zZXRXcmFwcGVyXHJcbiAgICAgIC5zdHlsZSgnb3BhY2l0eScsIDEpO1xyXG4gIH1cclxuXHJcbiAgcGxvdEFsbERhdGFEb3RzKHBldGFsczogUGV0YWxOb2RlW10sIHNob3dEb3RzOiBib29sZWFuLFxyXG4gICAgICAgICAgICAgICAgICBjb250ZXh0OiBHcmFwaGljQ29udGV4dCk6IEdyYXBoaWNDb250ZXh0IHtcclxuXHJcblxyXG4gICAgY29uc3QgdHJhbnNpdGlvbnNUaW1lID0gdGhpcy5sb29rQW5kRmVlbC5iYXNlVHJhbnNpdGlvbnNUaW1lO1xyXG4gICAgY29uc3QgZDMgPSB0aGlzLmQzO1xyXG4gICAgY29uc3QgcmFkaXVzID0gY29udGV4dC5yYWRpdXM7XHJcblxyXG4gICAgaWYgKCFjb250ZXh0LmRvdHNXcmFwcGVyKSB7XHJcbiAgICAgIGNvbnRleHQuZG90c1dyYXBwZXIgPSBjb250ZXh0Lm1haW5QYW5lLmFwcGVuZDxTVkdHRWxlbWVudD4oJ2cnKS5hdHRyKCdjbGFzcycsICdkb3RzV3JhcHBlcicpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgZG90c1dyYXBwZXIgPSBjb250ZXh0LmRvdHNXcmFwcGVyO1xyXG5cclxuICAgIGlmICghc2hvd0RvdHMpIHtcclxuICAgICAgY29udGV4dC5kb3RzV3JhcHBlci5zdHlsZSgnb3BhY2l0eScsIDAuMCk7XHJcbiAgICAgIHJldHVybiBjb250ZXh0O1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgY29udGV4dC5kb3RzV3JhcHBlci5zdHlsZSgnb3BhY2l0eScsIDEpO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGRvdHNEYXRhID0gcGV0YWxzLm1hcChwID0+IHAuaW5kaXZpZHVhbHMpO1xyXG4gICAgY29uc3QgaW5zdGFuY2UgPSB0aGlzO1xyXG5cclxuXHJcbiAgICAvLyBzbyB0aGF0IGFuZ3VsYXIgY2hhbmdlIGRldGVjdGlvbiBpcyBub3QgdHJpZ2dlcmVkIGZvciBtb3VzZW92ZXIvb3VyIGV2ZW50cyBvciB0cmFuc2l0aW9uc1xyXG4gICAgdGhpcy5uZ1pvbmUucnVuT3V0c2lkZUFuZ3VsYXIoKCkgPT4ge1xyXG5cclxuICAgICAgY29uc3QgZG90c0dyb3VwID0gZG90c1dyYXBwZXIuc2VsZWN0QWxsKCcuZG90c0dyb3VwJylcclxuICAgICAgICAuZGF0YShkb3RzRGF0YSk7XHJcblxyXG5cclxuICAgICAgY29uc3QgZG90c0luRXhpc3RpbmcgPSBkb3RzR3JvdXAuc2VsZWN0QWxsKCcuZG90c0NpcmNsZScpXHJcbiAgICAgICAgLmRhdGEoZCA9PiBkKTtcclxuXHJcbiAgICAgIGRvdHNJbkV4aXN0aW5nXHJcbiAgICAgICAgLnRyYW5zaXRpb24oKS5kdXJhdGlvbih0cmFuc2l0aW9uc1RpbWUpXHJcbiAgICAgICAgLmF0dHIoJ2N4JywgZCA9PiByYWRpdXMgKiBkLnh5WzBdKVxyXG4gICAgICAgIC5hdHRyKCdjeScsIGQgPT4gcmFkaXVzICogZC54eVsxXSkgLy8gTWF0aC5zaW4oZCAqIDIgKiBNYXRoLlBJIC8gMjQgLSBNYXRoLlBJIC8gMik7XHJcbiAgICAgICAgLnN0eWxlKCdzdHJva2UnLCBkID0+IGQuY29sb3IpXHJcbiAgICAgICAgLnN0eWxlKCdmaWxsJywgZCA9PiBkLmNvbG9yKVxyXG4gICAgICA7XHJcblxyXG4gICAgICBkb3RzSW5FeGlzdGluZy5lbnRlcigpXHJcbiAgICAgICAgLmFwcGVuZCgnY2lyY2xlJylcclxuICAgICAgICAuYXR0cignY2xhc3MnLCAnZG90c0NpcmNsZScpXHJcbiAgICAgICAgLnRyYW5zaXRpb24oKS5kdXJhdGlvbih0cmFuc2l0aW9uc1RpbWUpXHJcbiAgICAgICAgLmF0dHIoJ2N4JywgZCA9PiByYWRpdXMgKiBkLnh5WzBdKVxyXG4gICAgICAgIC5hdHRyKCdjeScsIGQgPT4gcmFkaXVzICogZC54eVsxXSkgLy8gTWF0aC5zaW4oZCAqIDIgKiBNYXRoLlBJIC8gMjQgLSBNYXRoLlBJIC8gMik7XHJcbiAgICAgICAgLmF0dHIoJ3InLCB0aGlzLmxvb2tBbmRGZWVsLmRvdHNDaXJjbGVSYWRpdXMpXHJcbiAgICAgICAgLnN0eWxlKCdzdHJva2Utd2lkdGgnLCB0aGlzLmxvb2tBbmRGZWVsLmRvdHNDaXJjbGVTdHJva2VXaWR0aClcclxuICAgICAgICAuc3R5bGUoJ3N0cm9rZScsIGQgPT4gZC5jb2xvcilcclxuICAgICAgICAuc3R5bGUoJ2ZpbGwnLCBkID0+IGQuY29sb3IpXHJcbiAgICAgICAgLnN0eWxlKCdmaWxsLW9wYWNpdHknLCB0aGlzLmxvb2tBbmRGZWVsLmRvdHNDaXJjbGVGaWxsT3BhY2l0eSk7XHJcblxyXG5cclxuICAgICAgZG90c0luRXhpc3RpbmcuZXhpdCgpXHJcbiAgICAgICAgLnRyYW5zaXRpb24oKS5kdXJhdGlvbih0cmFuc2l0aW9uc1RpbWUgLyAyKVxyXG4gICAgICAgIC5zdHlsZSgnb3BhY2l0eScsIDAuMClcclxuICAgICAgICAucmVtb3ZlKCk7XHJcblxyXG4gICAgICAvLyBkb3RzR3JvdXAgZW50ZXIgc2VjdGlvblxyXG4gICAgICBjb25zdCBkb3RzSW5OZXdHcm91cHMgPSBkb3RzR3JvdXAuZW50ZXIoKVxyXG4gICAgICAgIC5hcHBlbmQ8U1ZHR0VsZW1lbnQ+KCdnJylcclxuICAgICAgICAuYXR0cignY2xhc3MnLCAnZG90c0dyb3VwJylcclxuICAgICAgICAuc2VsZWN0QWxsKCcuZG90c0NpcmNsZScpXHJcbiAgICAgICAgLmRhdGEoZCA9PiBkKTtcclxuXHJcblxyXG4gICAgICBkb3RzSW5OZXdHcm91cHMuZW50ZXIoKVxyXG4gICAgICAgIC5hcHBlbmQoJ2NpcmNsZScpXHJcbiAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2RvdHNDaXJjbGUnKVxyXG4gICAgICAgIC50cmFuc2l0aW9uKCkuZHVyYXRpb24odHJhbnNpdGlvbnNUaW1lKVxyXG4gICAgICAgIC5hdHRyKCdjeCcsIGQgPT4gcmFkaXVzICogZC54eVswXSlcclxuICAgICAgICAuYXR0cignY3knLCBkID0+IHJhZGl1cyAqIGQueHlbMV0pIC8vIE1hdGguc2luKGQgKiAyICogTWF0aC5QSSAvIDI0IC0gTWF0aC5QSSAvIDIpO1xyXG4gICAgICAgIC5hdHRyKCdyJywgdGhpcy5sb29rQW5kRmVlbC5kb3RzQ2lyY2xlUmFkaXVzKVxyXG4gICAgICAgIC5zdHlsZSgnc3Ryb2tlLXdpZHRoJywgdGhpcy5sb29rQW5kRmVlbC5kb3RzQ2lyY2xlU3Ryb2tlV2lkdGgpXHJcbiAgICAgICAgLnN0eWxlKCdzdHJva2UnLCBkID0+IGQuY29sb3IpXHJcbiAgICAgICAgLnN0eWxlKCdmaWxsJywgZCA9PiBkLmNvbG9yKVxyXG4gICAgICAgIC5zdHlsZSgnZmlsbC1vcGFjaXR5JywgdGhpcy5sb29rQW5kRmVlbC5kb3RzQ2lyY2xlRmlsbE9wYWNpdHkpO1xyXG5cclxuICAgICAgLy8gZG90c0dyb3VwIGV4aXQgc2VjdGlvblxyXG4gICAgICBkb3RzR3JvdXAuZXhpdCgpXHJcbiAgICAgICAgLnRyYW5zaXRpb24oKS5kdXJhdGlvbih0cmFuc2l0aW9uc1RpbWUgLyAyKVxyXG4gICAgICAgIC5zdHlsZSgnb3BhY2l0eScsIDAuMClcclxuICAgICAgICAucmVtb3ZlKCk7XHJcblxyXG4gICAgfSk7XHJcblxyXG4gICAgY29uc3QgZG90c0dyb3VwID0gZG90c1dyYXBwZXIvLyAuc2VsZWN0QWxsKFwiLmRvdHNHcm91cFwiKVxyXG4gICAgICAuc2VsZWN0QWxsKCcuZG90c0NpcmNsZScpXHJcbiAgICAgIC8vIC5zdHlsZShcInZpc2liaWxpdHlcIiwgKG46UG9sYXJQb2ludCkgPT4gbi5oaWRkZW4gPyBcImhpZGRlblwiOlwidmlzaWJsZVwiKTtcclxuICAgICAgLnN0eWxlKCdkaXNwbGF5JywgKG46IFBvbGFyUG9pbnQpID0+IG4uaGlkZGVuID8gJ25vbmUnIDogbnVsbCk7XHJcblxyXG4gICAgcmV0dXJuIGNvbnRleHQ7XHJcbiAgfVxyXG5cclxuICAvKlxyXG4gIHBsb3RBbGxEYXRhRG90cyhkb3RzRGF0YTogUG9sYXJQb2ludFtdW10sIHNob3dEb3RzOiBib29sZWFuLFxyXG4gICAgICAgICAgICAgICAgICBjb250ZXh0OiBHcmFwaGljQ29udGV4dCk6IEdyYXBoaWNDb250ZXh0IHtcclxuXHJcblxyXG4gICAgY29uc3QgdHJhbnNpdGlvbnNUaW1lID0gdGhpcy5sb29rQW5kRmVlbC5iYXNlVHJhbnNpdGlvbnNUaW1lO1xyXG4gICAgY29uc3QgZDMgPSB0aGlzLmQzO1xyXG4gICAgY29uc3QgcmFkaXVzID0gY29udGV4dC5yYWRpdXM7XHJcblxyXG4gICAgaWYgKCFjb250ZXh0LmRvdHNXcmFwcGVyKSB7XHJcbiAgICAgIGNvbnRleHQuZG90c1dyYXBwZXIgPSBjb250ZXh0Lm1haW5QYW5lLmFwcGVuZDxTVkdHRWxlbWVudD4oJ2cnKS5hdHRyKCdjbGFzcycsICdkb3RzV3JhcHBlcicpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgZG90c1dyYXBwZXIgPSBjb250ZXh0LmRvdHNXcmFwcGVyO1xyXG5cclxuICAgIGlmICghc2hvd0RvdHMpIHtcclxuICAgICAgY29udGV4dC5kb3RzV3JhcHBlci5zdHlsZSgnb3BhY2l0eScsIDAuMCk7XHJcbiAgICAgIHJldHVybiBjb250ZXh0O1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgY29udGV4dC5kb3RzV3JhcHBlci5zdHlsZSgnb3BhY2l0eScsIDEpO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGluc3RhbmNlID0gdGhpcztcclxuXHJcblxyXG4gICAgLy8gc28gdGhhdCBhbmd1bGFyIGNoYW5nZSBkZXRlY3Rpb24gaXMgbm90IHRyaWdnZXJlZCBmb3IgbW91c2VvdmVyL291ciBldmVudHMgb3IgdHJhbnNpdGlvbnNcclxuICAgIHRoaXMubmdab25lLnJ1bk91dHNpZGVBbmd1bGFyKCgpID0+IHtcclxuXHJcbiAgICAgIGNvbnN0IGRvdHNHcm91cCA9IGRvdHNXcmFwcGVyLnNlbGVjdEFsbCgnLmRvdHNHcm91cCcpXHJcbiAgICAgICAgLmRhdGEoZG90c0RhdGEpO1xyXG5cclxuXHJcbiAgICAgIGNvbnN0IGRvdHNJbkV4aXN0aW5nID0gZG90c0dyb3VwLnNlbGVjdEFsbCgnLmRvdHNDaXJjbGUnKVxyXG4gICAgICAgIC5kYXRhKGQgPT4gZCk7XHJcblxyXG4gICAgICBkb3RzSW5FeGlzdGluZ1xyXG4gICAgICAgIC50cmFuc2l0aW9uKCkuZHVyYXRpb24odHJhbnNpdGlvbnNUaW1lKVxyXG4gICAgICAgIC5hdHRyKCdjeCcsIGQgPT4gcmFkaXVzICogZC54eVswXSlcclxuICAgICAgICAuYXR0cignY3knLCBkID0+IHJhZGl1cyAqIGQueHlbMV0pIC8vIE1hdGguc2luKGQgKiAyICogTWF0aC5QSSAvIDI0IC0gTWF0aC5QSSAvIDIpO1xyXG4gICAgICAgIC5zdHlsZSgnc3Ryb2tlJywgZCA9PiBkLmNvbG9yKVxyXG4gICAgICAgIC5zdHlsZSgnZmlsbCcsIGQgPT4gZC5jb2xvcilcclxuICAgICAgO1xyXG5cclxuICAgICAgZG90c0luRXhpc3RpbmcuZW50ZXIoKVxyXG4gICAgICAgIC5hcHBlbmQoJ2NpcmNsZScpXHJcbiAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2RvdHNDaXJjbGUnKVxyXG4gICAgICAgIC50cmFuc2l0aW9uKCkuZHVyYXRpb24odHJhbnNpdGlvbnNUaW1lKVxyXG4gICAgICAgIC5hdHRyKCdjeCcsIGQgPT4gcmFkaXVzICogZC54eVswXSlcclxuICAgICAgICAuYXR0cignY3knLCBkID0+IHJhZGl1cyAqIGQueHlbMV0pIC8vIE1hdGguc2luKGQgKiAyICogTWF0aC5QSSAvIDI0IC0gTWF0aC5QSSAvIDIpO1xyXG4gICAgICAgIC5hdHRyKCdyJywgdGhpcy5sb29rQW5kRmVlbC5kb3RzQ2lyY2xlUmFkaXVzKVxyXG4gICAgICAgIC5zdHlsZSgnc3Ryb2tlLXdpZHRoJywgdGhpcy5sb29rQW5kRmVlbC5kb3RzQ2lyY2xlU3Ryb2tlV2lkdGgpXHJcbiAgICAgICAgLnN0eWxlKCdzdHJva2UnLCBkID0+IGQuY29sb3IpXHJcbiAgICAgICAgLnN0eWxlKCdmaWxsJywgZCA9PiBkLmNvbG9yKVxyXG4gICAgICAgIC5zdHlsZSgnZmlsbC1vcGFjaXR5JywgdGhpcy5sb29rQW5kRmVlbC5kb3RzQ2lyY2xlRmlsbE9wYWNpdHkpO1xyXG5cclxuXHJcbiAgICAgIGRvdHNJbkV4aXN0aW5nLmV4aXQoKVxyXG4gICAgICAgIC50cmFuc2l0aW9uKCkuZHVyYXRpb24odHJhbnNpdGlvbnNUaW1lIC8gMilcclxuICAgICAgICAuc3R5bGUoJ29wYWNpdHknLCAwLjApXHJcbiAgICAgICAgLnJlbW92ZSgpO1xyXG5cclxuICAgICAgLy8gZG90c0dyb3VwIGVudGVyIHNlY3Rpb25cclxuICAgICAgY29uc3QgZG90c0luTmV3R3JvdXBzID0gZG90c0dyb3VwLmVudGVyKClcclxuICAgICAgICAuYXBwZW5kPFNWR0dFbGVtZW50PignZycpXHJcbiAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2RvdHNHcm91cCcpXHJcbiAgICAgICAgLnNlbGVjdEFsbCgnLmRvdHNDaXJjbGUnKVxyXG4gICAgICAgIC5kYXRhKGQgPT4gZCk7XHJcblxyXG5cclxuICAgICAgZG90c0luTmV3R3JvdXBzLmVudGVyKClcclxuICAgICAgICAuYXBwZW5kKCdjaXJjbGUnKVxyXG4gICAgICAgIC5hdHRyKCdjbGFzcycsICdkb3RzQ2lyY2xlJylcclxuICAgICAgICAudHJhbnNpdGlvbigpLmR1cmF0aW9uKHRyYW5zaXRpb25zVGltZSlcclxuICAgICAgICAuYXR0cignY3gnLCBkID0+IHJhZGl1cyAqIGQueHlbMF0pXHJcbiAgICAgICAgLmF0dHIoJ2N5JywgZCA9PiByYWRpdXMgKiBkLnh5WzFdKSAvLyBNYXRoLnNpbihkICogMiAqIE1hdGguUEkgLyAyNCAtIE1hdGguUEkgLyAyKTtcclxuICAgICAgICAuYXR0cigncicsIHRoaXMubG9va0FuZEZlZWwuZG90c0NpcmNsZVJhZGl1cylcclxuICAgICAgICAuc3R5bGUoJ3N0cm9rZS13aWR0aCcsIHRoaXMubG9va0FuZEZlZWwuZG90c0NpcmNsZVN0cm9rZVdpZHRoKVxyXG4gICAgICAgIC5zdHlsZSgnc3Ryb2tlJywgZCA9PiBkLmNvbG9yKVxyXG4gICAgICAgIC5zdHlsZSgnZmlsbCcsIGQgPT4gZC5jb2xvcilcclxuICAgICAgICAuc3R5bGUoJ2ZpbGwtb3BhY2l0eScsIHRoaXMubG9va0FuZEZlZWwuZG90c0NpcmNsZUZpbGxPcGFjaXR5KTtcclxuXHJcbiAgICAgIC8vIGRvdHNHcm91cCBleGl0IHNlY3Rpb25cclxuICAgICAgZG90c0dyb3VwLmV4aXQoKVxyXG4gICAgICAgIC50cmFuc2l0aW9uKCkuZHVyYXRpb24odHJhbnNpdGlvbnNUaW1lIC8gMilcclxuICAgICAgICAuc3R5bGUoJ29wYWNpdHknLCAwLjApXHJcbiAgICAgICAgLnJlbW92ZSgpO1xyXG5cclxuICAgIH0pO1xyXG5cclxuICAgIGNvbnN0IGRvdHNHcm91cCA9IGRvdHNXcmFwcGVyLy8gLnNlbGVjdEFsbChcIi5kb3RzR3JvdXBcIilcclxuICAgICAgLnNlbGVjdEFsbCgnLmRvdHNDaXJjbGUnKVxyXG4gICAgICAvLyAuc3R5bGUoXCJ2aXNpYmlsaXR5XCIsIChuOlBvbGFyUG9pbnQpID0+IG4uaGlkZGVuID8gXCJoaWRkZW5cIjpcInZpc2libGVcIik7XHJcbiAgICAgIC5zdHlsZSgnZGlzcGxheScsIChuOiBQb2xhclBvaW50KSA9PiBuLmhpZGRlbiA/ICdub25lJyA6IG51bGwpO1xyXG5cclxuICAgIHJldHVybiBjb250ZXh0O1xyXG4gIH1cclxuICAqL1xyXG5cclxuICBwbG90QXhpc0dyaWQoY29udGV4dDogR3JhcGhpY0NvbnRleHQpOiBHcmFwaGljQ29udGV4dCB7XHJcblxyXG5cclxuICAgIGlmIChjb250ZXh0LmF4aXNHcmlkKSB7XHJcbiAgICAgIHJldHVybiBjb250ZXh0OyAvLyB0aGlzLmF4aXNHcmlkOyAvL3dlIG9ubHkgcGxvdCBncmlkIG9uY2VcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCByYWRpdXMgPSBjb250ZXh0LnJhZGl1cztcclxuICAgIGNvbnN0IGF4aXNHcmlkID0gY29udGV4dC5heGlzR3JpZCA9IGNvbnRleHQubWFpblBhbmUuYXBwZW5kPFNWR0dFbGVtZW50PignZycpLmF0dHIoJ2NsYXNzJywgJ2F4aXNXcmFwcGVyJyk7XHJcblxyXG5cclxuICAgIGF4aXNHcmlkLnNlbGVjdEFsbCgnLmxldmVscycpXHJcbiAgICAgIC5kYXRhKFsxMCwgMiwgMV0pXHJcbiAgICAgIC5lbnRlcigpXHJcbiAgICAgIC5hcHBlbmQoJ2NpcmNsZScpXHJcbiAgICAgIC5hdHRyKCdjbGFzcycsICdncmlkQ2lyY2xlJylcclxuICAgICAgLmF0dHIoJ3InLCBmdW5jdGlvbihkLCBpKSB7XHJcbiAgICAgICAgcmV0dXJuIHJhZGl1cyAvIGQ7XHJcbiAgICAgIH0pXHJcbiAgICAgIC5zdHlsZSgnZmlsbCcsIHRoaXMubG9va0FuZEZlZWwuZ3JpZENvbG9yKVxyXG4gICAgICAuc3R5bGUoJ3N0cm9rZScsIHRoaXMubG9va0FuZEZlZWwuZ3JpZENvbG9yKVxyXG4gICAgICAuc3R5bGUoJ2ZpbGwtb3BhY2l0eScsIDAuMTUpO1xyXG4gICAgLy8gLnN0eWxlKFwiZmlsdGVyXCIgLCBcInVybCgjZ2xvdylcIik7XHJcblxyXG4gICAgY29uc3QgYXhpcyA9IGF4aXNHcmlkLnNlbGVjdEFsbCgnLmF4aXMnKVxyXG4gICAgICAuZGF0YShcclxuICAgICAgICBbMCwgMywgNiwgOSwgMTIsIDE1LCAxOCwgMjFdLm1hcCh2ID0+IHRoaXMucG9sYXJVdGlsLm5vcm1hbGl6ZWRQZWFrVG9Qb2xhcih2LCAyNClcclxuICAgICAgICAgIC8vIHBvbGFyIGNvb3JkaW5hdGVzIHdpdGggYXR0YWNoZWQgb3JpZ2luYWwgdmFsdWUgZm9yIHRoZSBsYWJlbFxyXG4gICAgICAgIClcclxuICAgICAgKVxyXG4gICAgICAuZW50ZXIoKVxyXG4gICAgICAuYXBwZW5kKCdnJylcclxuICAgICAgLmF0dHIoJ2NsYXNzJywgJ2F4aXMnKTtcclxuXHJcbiAgICBheGlzLmFwcGVuZCgnbGluZScpXHJcbiAgICAgIC5hdHRyKCd4MScsIDApXHJcbiAgICAgIC5hdHRyKCd5MScsIDApXHJcbiAgICAgIC5hdHRyKCd4MicsIGZ1bmN0aW9uKGQsIGkpIHtcclxuICAgICAgICByZXR1cm4gcmFkaXVzICogZFswXTsgLy8gTWF0aC5jb3MoZCAqIDIgKiBNYXRoLlBJIC8gMjQgLSBNYXRoLlBJIC8gMik7XHJcbiAgICAgIH0pXHJcbiAgICAgIC5hdHRyKCd5MicsIGZ1bmN0aW9uKGQsIGkpIHtcclxuICAgICAgICByZXR1cm4gcmFkaXVzICogZFsxXTsgLy8gTWF0aC5zaW4oZCAqIDIgKiBNYXRoLlBJIC8gMjQgLSBNYXRoLlBJIC8gMik7XHJcbiAgICAgIH0pXHJcbiAgICAgIC5hdHRyKCdjbGFzcycsICdsaW5lJylcclxuICAgICAgLnN0eWxlKCdzdHJva2UnLCB0aGlzLmxvb2tBbmRGZWVsLmF4aXNDb2xvcilcclxuICAgICAgLnN0eWxlKCdzdHJva2UtZGFzaGFycmF5JywgJzUgNScpXHJcbiAgICAgIC5zdHlsZSgnc3Ryb2tlLXdpZHRoJywgdGhpcy5sb29rQW5kRmVlbC5heGlzV2lkdGgpO1xyXG5cclxuICAgIGF4aXMuYXBwZW5kKCd0ZXh0JylcclxuICAgICAgLmF0dHIoJ2NsYXNzJywgJ2xlZ2VuZCcpXHJcbiAgICAgIC8vIC5zdHlsZShcImZvbnQtc2l6ZVwiLCB0aGlzLmxvb2tBbmRGZWVsLmF4aXNGb250U2l6ZSkgLy9cIjEwcHhcIilcclxuICAgICAgLmF0dHIoJ3RleHQtYW5jaG9yJywgJ21pZGRsZScpXHJcbiAgICAgIC5hdHRyKCdkeScsICcwLjM1ZW0nKVxyXG4gICAgICAuYXR0cigneCcsIGZ1bmN0aW9uKGQsIGkpIHtcclxuICAgICAgICByZXR1cm4gKHJhZGl1cyArIDE1KSAqIGRbMF07IC8vIE1hdGguY29zKGQgKiAyICogTWF0aC5QSSAvIDI0IC0gTWF0aC5QSSAvIDIpO1xyXG4gICAgICB9KVxyXG4gICAgICAuYXR0cigneScsIGZ1bmN0aW9uKGQsIGkpIHtcclxuICAgICAgICByZXR1cm4gKHJhZGl1cyArIDE1KSAqIGRbMV07IC8vIE1hdGguc2luKGQgKiAyICogTWF0aC5QSSAvIDI0IC0gTWF0aC5QSSAvIDIpO1xyXG4gICAgICB9KVxyXG4gICAgICAudGV4dChmdW5jdGlvbihkLCBpKSB7XHJcbiAgICAgICAgcmV0dXJuIGRbMl07XHJcbiAgICAgIH0pO1xyXG5cclxuICAgIHJldHVybiBjb250ZXh0O1xyXG4gIH1cclxuXHJcbiAgdXBkYXRlQXhpc0xhYmVscyhkb21haW46IG51bWJlcltdLCBheGlzR3JpZDogU2VsZWN0aW9uPFNWR0dFbGVtZW50LCBhbnksIG51bGwsIHVuZGVmaW5lZD4pIHtcclxuXHJcbiAgICBjb25zdCByYW5nZSA9IGRvbWFpblsxXSAtIGRvbWFpblswXTtcclxuICAgIGNvbnN0IGF4aXMgPSBheGlzR3JpZC5zZWxlY3RBbGwoJy5heGlzJyk7XHJcbiAgICBheGlzLnNlbGVjdCgndGV4dCcpXHJcbiAgICAgIC50ZXh0KGZ1bmN0aW9uKGQsIGkpIHtcclxuICAgICAgICBpZiAoaSA9PT0gMCkge1xyXG4gICAgICAgICAgcmV0dXJuIFNtYXJ0Um91bmRlci5yb3VuZChkb21haW5bMV0pICsgJyAvICcgKyBTbWFydFJvdW5kZXIucm91bmQoZG9tYWluWzBdKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgcmV0dXJuIFNtYXJ0Um91bmRlci5yb3VuZChkb21haW5bMF0gKyBkWzJdIC8gMjQgKiByYW5nZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuXHJcbiAgfVxyXG5cclxufVxyXG4iXX0=